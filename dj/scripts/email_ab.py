#!/usr/bin/python

# email_ab.py
# abstract email class

from django.core.mail import get_connection, EmailMessage

from django.template import Context, Template

from process import process
from django.conf import settings

import random

class email_ab(process):

    subject_template = "stub testing:{{ep.name}}"
    body_template = "stub testing:{{ep.description}}"

    footer = """
Email generated by https://github.com/CarlFK/veyepar/blob/master/dj/scripts/{{py_name}}
but replies go to real people.

Reference: http://veyepar.nextdayvideo.com/main/E/{{ep.id}}/
"""
    py_name = "email_ab.py"

   
    def more_context(self, ep):
        # hook to specify more context
        # like png url
        return {}

    def process_ep(self, ep):

        # if there is no email, use the client's.
        # like for lightning talks.
        emails = ep.emails or ep.show.client.contacts

        if self.options.verbose: print emails

        if emails: 
            tos = [e.strip() for e in emails.split(',')]

            subject = Template(self.subject_template).render(
                    Context({'ep':ep}, autoescape=False))

            context = { 'ep':ep, 
                    'py_name':self.py_name, 
                    # 'MEDIA_URL':settings.MEDIA_URL,
                    }
            more_context = self.more_context(ep)
            for k in more_context:
                context[k] = more_context[k]
            
            body = Template( self.body_template + self.footer 
                    ).render(Context(context, autoescape=False))

            # sender = 'Carl Karsten <carl@nextdayvideo.com>'
            sender = settings.EMAIL_SENDER
            # make a list of addresses:
            reply_tos = [sender] + ep.show.client.contacts.split(',')
            # headers={Reply-To... needs to be a string of comma seperated 
            reply_to = ','.join( reply_tos )
            headers = {
                     'Reply-To': reply_to,
                    # 'From': sender,
                        }    

            if self.options.test:
                print "tos:", tos
                print "subject:", subject
                print "headers:", headers
                print "context:", context
                print "body:", body
                ret = False
            else:

                email = EmailMessage(subject, body, sender, tos, headers=headers ) 
                connection = get_connection()
                ret = connection.send_messages([email])
                print tos, ret
                ret = True # need to figure out what .send_messages returns

        else:
            print "no emails!"
            ret = False

        return ret

if __name__ == '__main__':
    p=email_ab()
    p.main()

