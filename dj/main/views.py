from django.shortcuts import render_to_response, get_object_or_404
from django.contrib.auth import authenticate, login
from django.contrib.auth.models import User, Group
from django.contrib.auth.decorators import login_required
from django.shortcuts import render
from django.template import RequestContext
from django.template import Context, loader

from django.core.paginator import Paginator, InvalidPage, EmptyPage, PageNotAnInteger
from django.conf import settings

from django import forms
from django.forms import ModelForm
from django.forms.formsets import formset_factory

from django.db.models import Q
from django.db.models import Count, Max
from django.db.models.functions import Trunc

from django.http import HttpResponse, HttpResponseRedirect, Http404
from django.core import serializers
from django.core.urlresolvers import reverse
from django.core.mail import get_connection, EmailMessage

# from django.utils import simplejson

import datetime
import os
import csv
from copy import deepcopy

from io import BytesIO
import json
from pprint import pprint
import operator

import urllib.parse

from main.models import \
        Client, Show, Location, Episode, Cut_List, Raw_File,\
        State, Image_File,Log, Mark

from main.models import STATES, ANN_STATES
from main.forms import \
        Episode_Form_small, Episode_Form_Preshow, \
        Location_Form, \
        clrfForm, Add_CutList_to_Ep, Who, AddImageToEp, \
        Episode_Form_Mini, MarkPicker


from accounts.forms import LoginForm


def main(request):
    return render(request, 'main.html')

def make_test_data(
        title="Test Episode",
        start_time=datetime.datetime(2010,5,21,0,0,4)):

    # start_time
    # datetime matches what run_tests.sh uses to create files.
    # the scheduled start time is at 4 seconds
    # in the middle of the 2nd clip
    # t=datetime.datetime(2010,5,21,0,0,4)

    desc = """
Sample files and episode:
file 0 and 4 are outside the range
file 1 and 3 are overlap the episode start/end
file 2 inside the start/end
e=episode,r=raw files
time: 0  1  2  3  4  5  6  7
raws:  00 11111 22 33333 44
episode:     XXXXXXXXX
"""

    # get/create a location, client and show.
    # append additional episodes

    loc,create = Location.objects.get_or_create(
            name='test loc',slug='test_loc')
    client,create = Client.objects.get_or_create(
            name='test client',slug='test_client',
            )
    client.title_svg='test_show_title.svg'
    client.category_key='test'
    client.youtube_id='test'
    client.archive_id=''
    client.tweet_id='test'
    client.tweet_prefix='test'
    client.rax_id='testact'
    client.bucket_id='example'
    client.richard_id='test'
            # title_svg = "pycon2013.svg",
            # host_user='veyepar_test',
            # 00000001.png gets generated by mplayer,
            # no easy way to make it a pretty name.
    client.credits="00000001.png"
    client.save()

    show,create = Show.objects.get_or_create( client=client,
                    name='test show',slug='test_show',)
    if create:
        show.locations.add(loc)

    ep = Episode.objects.create(
        show=show,
        location=loc,
        name=title,
        state=1,
        active = True,
        released=True,
        start = start_time,
        duration = "00:00:06",
        )

    # ep.name = "Test Episode"
    # ep.name = u'TECHNICI\xc3\x84NS \xc3\x96F CH\xc4\xa8P\xc3\x9d THIS IS Y\xc3\x96\xc3\x9cR C\xc3\x84PT\xc3\x85IN SPE\xc3\x84KING Y\xc3\x96\xc3\x9cR \xc3\x98\xc3\x85PT\xc3\x85IN IS DEA\xcc\x8bD'

    ep.sequence = 1
    ep.description = desc
    ep.authors = "Test Author"
    ep.emails = "cfkarsten@gmail.com"
    ep.tags ="tag1,tag_2,tag 3"
    ep.save()

    return ep

def del_test_data():
    clients = Client.objects.filter(slug='test_client')
    if clients: clients[0].delete()

def tests(request):

    if request.method == 'POST':
        if 'create' in request.POST:
            make_test_data()
        if 'delete' in request.POST:
            del_test_data()

    locations=Location.objects.filter(slug__contains="test")
    clients=Client.objects.filter(slug__contains="test")
    shows=Show.objects.filter(slug__contains="test")
    episodes=Episode.objects.filter(slug__contains="test")

    return render(request,'tests.html',
       locals())

def start_here(request):
    """
    landing page for someone who has never been here before
    and wants to help.
    """

    show=get_object_or_404(Show,
            client__slug='eric',slug='write_docs_na_2016')
    episodes = Episode.objects.filter(show=show,
            location__active=True,
            state=1,
            locked__isnull=True,
            )
    # episodes = episodes.annotate(
    #                c=Count("cut_list")).filter(c__gte=1)
    episode = episodes[0]

    if request.method == 'POST':
        who = Who(request.POST)
        if who.is_valid():
            episode.locked_by = who.cleaned_data['locked_by']
            episode.locked = datetime.datetime.now()
            episode.save()
            return HttpResponseRedirect(
                    reverse(approve_episode,
                     args=(episode.id, episode.slug, episode.edit_key,)))
    else:
        who = Who()

    return render(request, 'start_here.html',
        {'show':show,
         'episode':episode,
         'who':who,},
       )

def veyepar_cfg(request):

    cfg_lines = ["[global]"]

    shows=Show.objects.annotate( max_date=Max('episode__start'))\
            .order_by('-max_date')
    # filter(max_date__ge=now)\

    for show in shows:
        print(show)
        if show.max_date is None:
            continue
        # print( show.max_date,  datetime.datetime.now())#  datetime.timedelta(days=1):
        if show.max_date < datetime.datetime.now(): # - datetime.timedelta(days=1):
            break

        cfg_lines.append("")

        active = "" if show.active else "# "
        cfg_lines.append("{active}client={client}".format(
            active=active,client=show.client.slug))
        cfg_lines.append("{active}show={show}".format(
            active=active,show=show.slug))

        locations=show.locations.filter(active=True).order_by('sequence')
        for loc in locations:
            cfg_lines.append("room={slug}".format(slug=loc.slug))

    cfg = '\n'.join(cfg_lines)

    response = HttpResponse(cfg, content_type="text/plain")
    response['Content-Disposition'] = 'inline; filename=veyepar.cfg'

    return response


def eps_csv(request,client_slug=None,show_slug=None):
    client=get_object_or_404(Client,slug=client_slug)
    show=get_object_or_404(Show,client=client,slug=show_slug)
    eps = Episode.objects.filter(show=show)

    rows = [(ep.id,
            ep.state,
            ep.name,
            ep.conf_key,
            ep.conf_url,
            ep.host_url) for ep in eps]

    # url = request.GET['url']
    response = HttpResponse(content_type="application/csv")
    response['Content-Disposition'] = \
            'inline; filename={}.csv'.format(show.slug)
    writer = csv.writer(response)
    for ep in eps:
        row = [ep.id,
            ep.state,
            ep.slug.encode('utf-8'),
            # ep.name,
            ep.conf_key,
            ep.conf_url,
            ep.host_url,
            ]
        writer.writerow(row)

    return response

def ep_json(request, ep_id):

    """
    for pyvideo
    """

    ep = Episode.objects.get( id=ep_id )

    videos = []
    for t,u in (
                ( 'host', ep.host_url ),
                ( 'public', ep.public_url ),
                ( 'archive', ep.archive_ogv_url ),
                ( 'archive', ep.archive_url ),
                ( 'archive', ep.archive_mp4_url ),
                ( 'rax', ep.rax_mp4_url ),
                ( 'conf', ep.conf_url ),
                ( 'tweet', ep.twitter_url ),
            ):
        if u:
            videos.append(
                {
                  "length": None,
                  "type": t,
                  "url": u
                }
                )

    d = {
      "category": ep.show.client.category_key,
      "copyright_text": ep.license,
      "description": ep.description,
      "duration": ep.cuts_time(),
      "language": ep.language or "eng",
      "quality_notes": ep.video_quality,
      "recorded": ep.start.isoformat(),
      "slug": ep.slug,
      "source_url": ep.host_url,
      "speakers": ep.get_authors(),
      "summary": ep.summary,
      "tags": [] if ( (ep.tags is None) or (not ep.tags)) \
              else ep.tags.split(','),
      "thumbnail_url": ep.thumbnail,
      "title": ep.name,
      "videos": videos,
      "veyepar_state": ep.state,
    }

    response = HttpResponse(content_type="application/json")
    json.dump(d,response, indent=2)
    return response

def pyvid_jsons(request):

    episodes = eps_filters(request.GET)

    urls=[ 'wget -i "http://{host}{path}"'.format(
                host = request.META['HTTP_HOST'],
                path = request.get_full_path() )
            ]
    for ep in episodes:
        urls.append("http://{host}/main/E/{id}.json".format(host=request.META['HTTP_HOST'],id=ep.id))

    response = HttpResponse('\n'.join(urls), content_type="text/plain")
    response['Content-Disposition'] = \
            'inline; filename=veyepar.urls'

    return response

def eps_xfer(request,client_slug=None,show_slug=None):

    """
    Returns all the episodes for a show as json.
    Used to synk public url's with the main conference site.
    """

    client=get_object_or_404(Client,slug=client_slug)
    show=get_object_or_404(Show,client=client,slug=show_slug)
    eps = Episode.objects.filter(show=show)

    if "id" in request.GET:
        eps = eps.filter( id=request.GET['id'] )

    fields=['id',
            'state',
            'location',
            'get_location_name',
            'sequence',
            'name', 'slug', 'authors', 'description',
            'start', 'duration',
            'released', 'license', 'tags',
            'conf_key', 'conf_url',
            'host_url', 'public_url', 'rax_mp4_url', 'archive_mp4_url',
            'twitter_url',
            'comment',
        ]
    if request.user.is_authenticated():
        fields.extend(['emails', 'edit_key','conf_meta'])

    response = HttpResponse(content_type="application/json")
    serializers.serialize("json", eps,
            fields=fields, use_natural_foreign_keys=True,
            stream=response)

    return response


def eps_lanynard(request,client_slug=None,show_slug=None):
    """
    json feed to send to Lanyard, cuz wacky backward.
    https://docs.google.com/document/d/1aT_mIJ7Q-eawamGs_9HrBZL_Lfa0dBohXhc1SpfYSj0/pub?embedded=true
    """

    client=get_object_or_404(Client,slug=client_slug)
    show=get_object_or_404(Show,client=client,slug=show_slug)
    eps = Episode.objects.filter(show=show)

    #venue id - SEP
    vid=request.GET.get('vid','')

    field_map = (
            ('conf_url','crowdsource_ref'),
            ('name','title'),
            ('description','abstract'),
            # ('','start_time'),
            # ('','end_time'),
            # ('location','space_name'),
            # ('','venue'),
            # ('','speakers'),
            )


    sessions = []
    for ep in eps:
        session = {}
        for s,d in field_map:
            session[d]=getattr(ep,s)
        session['start_time'] = ep.start.strftime('%Y-%m-%d %H:%M:%S')
        session['end_time'] = ep.end.strftime('%Y-%m-%d %H:%M:%S')
        session['venue'] = vid
        session['space_map'] = ep.location.name

        speakers=[]
        if ep.authors:
            for i,name in enumerate(ep.authors.split(',')):
                speaker={'crowdsource_ref': "{0}/speakers/{1}".format(
                            session['crowdsource_ref'],i),
                         'name':name,
                         'role':'',
                         }
                speakers.append(speaker)
        session['speakers']=speakers

        sessions.append(session)


    response = HttpResponse(content_type="application/json")
    json.dump(sessions,response)

    return response

def meet_ann(request,show_id):
    show=get_object_or_404(Show,id=show_id)
    client=show.client
    episodes=Episode.objects.filter(show=show).order_by('start')
    location=episodes[0].location
    t = loader.get_template('meeting_announcement.html')
    c = Context(
        {'client':client,'show':show,
          'ANN_STATES': ANN_STATES,
          'location':location,
          'episodes':episodes,
    })
    r = t.render(c)
    if request:
        return HttpResponse("<pre>%s</pre>" % r)
    else:
        # called from emailer
        r=r.split('\n')
        subject = r[1]
        body = '\n'.join(r[3:])
        return subject,body

def emailer(show_id, ):
    show=get_object_or_404(Show,id=show_id)

    # show.announcement_state drives which of the following 3 get used:
    # 1. preview is for proofing the whole thing
    # 2. review is for the presenters to review their part
    # 3. approved means it is ready for distribution

    admin_emails = ['carl@personnelware.com', ]

    def author_emails(show):
        # return a list of email addresses for the show
        # pems = [ '"Brian Moloney" <brian@imagescape.com>' ]
        pems = [ 'brianhray@gmail.com' ]
        episodes=Episode.objects.filter(show=show)
        for ep in episodes:
            if ep.emails:
                emails = ep.emails.split(',')
                pems.extend(emails)
        return pems

# need to join the #ed lists
    announce_lists = [
 # '"ChiPy" <chicago@python.org>',
 '"ChiPy Announce" <ChiPy-announce@python.org>',
 '"PS1" <pumping-station-one-public@googlegroups.com>',
 '"ACM Chicago" <mtemkin@speakeasy.net>',
 # '"ACM Chicago" <chicago-chapter-acm@googlegroups.com>',
 # '"Chicago Linux Discuss" <chicagolinux-discuss@googlegroups.com>',
 # '"UFO Chicago" <ufo@ufo.chicago.il.us>',
 '<chicagotechcal@gmail.com>',
 'clclinuxclub@gmail.com',
 ]
    tos = { 1: admin_emails,
             2: author_emails(show),
             3: announce_lists}[show.announcement_state]

    subject,body=meet_ann(None,show_id)
    print(subject)
    print(body)
    print(tos)

    # connect to the smtp server
    connection = get_connection()
    sender = 'Carl Karsten <cfkarsten@gmail.com>'
    headers = {
        # 'Reply-To': "ChiPy <chicago@python.org>"
        # 'From': sender,
        }
    for to in tos:
        email = EmailMessage(subject, body, sender, [to], headers=headers )
        ret = connection.send_messages([email])
        print(to, ret)

    return

def show_urls(request,show_id):
    show=get_object_or_404(Show,id=show_id)
    client=show.client
    episodes=Episode.objects.filter(show=show).order_by('start')

    return render(request, "show_urls.html",
        {
          'client':client,
            'show':show,
            'episodes':episodes,
            },
        )

def schedule(request, show_id, show_slug, template_name):

    if "blank" in request.GET:
        blank_me = True
    else:
        blank_me = False

    show=get_object_or_404(Show,id=show_id)
    locations=show.locations.filter(active=True).order_by('sequence')
    episodes=Episode.objects.filter(show=show)

    if "released" in request.GET:
        episodes = episodes.filter(released=request.GET['released'])


    # order_by to override Meta: ordering = ["sequence"]
    # which will get included in the field list and break the .distinct().
    times=episodes.order_by('start').values('start','end').distinct()
    times=episodes.order_by('start').values('start').distinct()

    dates = list(set(t['start'].date() for t in times))
    dates.sort()

    # pprint([s for s in starts if s.date()==dates[1]])

    # [[d1,[[t1,[e1,e2,e3]],
    #       [t2,[e4,e5,e6]]],
    #  [d2,[[t3,[e7,e8,e9]]]]]]

    days=[]
    for d in dates:
        rows=[]
        for t in times:
            if t['start'].date() == d:
                slots=[]
                for loc in locations:
                    i=None
                    for ep in episodes:
                        if ep.location == loc and  ep.start == t['start'] :
                            i = ep
                    slots.append(i)
                rows.append([t,slots])
        days.append([d,rows])


    return render(request, template_name,
        {'show':show,
        'locations':locations,
        'blank_me':True,
        'days':days},
         )

def episode_pdfs(request, show_id, episode_id=None, rfxml='test.rfxml'):
    """
    Generates a pdf
    for all episodes in a show or just one episode
    layout defined by rfxml
    """
    try:
        from dabo.dReportWriter import dReportWriter
    except ImportError:
        raise Http404("Dabo is not installed")

    show=get_object_or_404(Show,id=show_id)
    client = show.client

    if episode_id:
        episodes=Episode.objects.filter(id=episode_id)
    else:
        episodes=Episode.objects \
                .annotate(start_date=Trunc('start', 'day')) \
                .filter(show=show, location__active=True ) \
                .order_by('start_date', 'location__sequence','start')
                # ).order_by('location__sequence','start')

    if "day" in request.GET:
        episodes = episodes.filter( start__day=request.GET['day'] )
    if "date" in request.GET:
        episodes = episodes.filter( start__startswith=request.GET['date'] )
    if "state" in request.GET:
        episodes = episodes.filter( state=request.GET['state'] )

    if "room" in request.GET:
        episodes = episodes.filter( location__slug=request.GET['room'] )

    base  = os.path.dirname(__file__)
    rfxmlfile  = os.path.join(base,'templates', rfxml+".rfxml")

    # buffer to create pdf in
    buf = BytesIO()

    # nonstandard font.  (not sure what standard is.)
    # fontfile = get_templete_abspath('badges/fonts/FreeSans.ttf')
    # pdfmetrics.registerFont(TTFont("FreeSans", fontfile))

    ds=[]
    for ep in episodes:
        if ep.location:
            location_name=ep.location.name
            location_slug=ep.location.slug
        else:
            location_name='None'
        ds.append({'episode_id':ep.id,
          'episode_conf_key':ep.conf_key,
          'episode_primary':ep.conf_key,
          'episode_name':ep.name,
          'episode_authors':ep.authors,
          'episode_emails':
            ep.emails if request.user.is_authenticated() else '',
          'episode_start':ep.start,
          'episode_duration':ep.duration,
          'episode_end':ep.end,
          'episode_released':ep.released,
          'episode_comment':ep.comment,
          'location_name':location_name,
          'location_slug':location_slug,
          'client_name':client.name,
          'show_name':show.name,
          })

    # generate the pdf in the buffer, using the layout and data
    rw = dReportWriter(OutputFile=buf, ReportFormFile=rfxmlfile, Cursor=ds)
    rw.write()

    # get the pdf out of the buffer
    pdf = buf.getvalue()
    buf.close()

    response = HttpResponse(content_type='application/pdf')
    e_id = episode_id if episode_id else 'all'
    filename = '_'.join( [client.slug, show.slug, e_id, rfxml] )
    response['Content-Disposition'] = \
      'filename=%s.pdf' % ( filename )
    response.write(pdf)
    return response

def mk_play_list(request):
    url = request.GET['url']
    response = HttpResponse(content_type='audio/mpegurl')
    response['Content-Disposition'] = 'inline; filename=playlist.m3u'
    writer = csv.writer(response)
    writer.writerow([url])
    return response

def raw_play_list(request, episode_id):
    episode=get_object_or_404(Episode,id=episode_id)
    show=episode.show
    client=show.client

    # cuts = Cut_List.objects.filter(episode=episode).order_by('raw_file__start')
    cuts = Cut_List.objects.filter(episode=episode).order_by('sequence', 'raw_file__start')
    if request.GET.get('apply') == 'yes':
        # if we only want the 'applied' files
        cuts = cuts.filter(apply=True)

    response = HttpResponse(content_type='audio/mpegurl')
    # response['Content-Disposition'] = 'attachment; filename=playlist.m3u'
    response['Content-Disposition'] = 'inline; filename=playlist.m3u'

    writer = csv.writer(response)
    # if request.GET.get('META.HTTP_HOST') == "localhost:8080":
    #    head="file://~Videos/xxx"
    # else:
    head=settings.MEDIA_URL
    for cut in cuts:

        if "ext" in request.GET:
            # this assumes the ext being removed is "dv" (2 chars)
            pathname = os.path.join(head,client.slug,show.slug,'dv',cut.raw_file.location.slug, cut.raw_file.filename )[:-2]+request.GET['ext']
        else:
            pathname = os.path.join(head,client.slug,show.slug,'dv',cut.raw_file.location.slug, cut.raw_file.filename )

        writer.writerow([pathname])

    return response

def eps_filters(rGET):

    episodes = Episode.objects.all()

    if "id" in rGET:
        episodes = episodes.filter( id=rGET['id'] )

    if "client" in rGET:
        episodes = episodes.filter(
                show__client__slug=rGET['client'] )

    if "show" in rGET:
        episodes = episodes.filter( show__slug=rGET['show'] )

    if "location" in rGET:
        episodes = episodes.filter( location__slug=rGET['location'] )

    if "date" in rGET:
        episodes = episodes.filter( start__startswith=rGET['date'] )

    if "state" in rGET:
        episodes = episodes.filter( state=rGET['state'] )

    return episodes


def public_play_list(request):
    # experiment to construct a playlist that is based on query params

    # build up the filter:
    episodes = eps_filters(request.GET)

    """
    if "id" in request.GET:
        episodes = episodes.filter( id=request.GET['id'] )

    if "client" in request.GET:
        episodes = episodes.filter(
                show__client__slug=request.GET['client'] )

    if "show" in request.GET:
        episodes = episodes.filter( show__slug=request.GET['show'] )

    if "location" in request.GET:
        episodes = episodes.filter( location__slug=request.GET['location'] )

    if "date" in request.GET:
        episodes = episodes.filter( start__startswith=request.GET['date'] )

    if "state" in request.GET:
        episodes = episodes.filter( state=request.GET['state'] )

    """

    response = HttpResponse(content_type='audio/mpegurl')
    # response['Content-Disposition'] = 'attachment; filename=playlist.m3u'
    response['Content-Disposition'] = 'inline; filename=playlist.m3u'

    # create the base of the URLs
    head=settings.MEDIA_URL
    # show_url = os.path.join(head,client.slug,show.slug)

    ext = "mp4"

    writer = csv.writer(response)
    for ep in episodes:
        show_url = os.path.join("/home/carl/Videos/veyepar",
                ep.show.client.slug, ep.show.slug)
        writer.writerow([os.path.join(
            show_url, ext, "{}.{}".format(ep.slug,ext))])
        if ep.public_url:
            writer.writerow([ep.public_url])

    return response


def enc_play_list(request,episode_id):
    episode=get_object_or_404(Episode,id=episode_id)
    show =episode.show
    client=show.client

    response = HttpResponse(content_type='audio/mpegurl')
    # response['Content-Disposition'] = 'attachment; filename=playlist.m3u'
    response['Content-Disposition'] = 'inline; filename=playlist.m3u'

    writer = csv.writer(response)
    # exts = [ 'ogv','flv', 'mp4', 'm4v', 'ogg', 'mp3' ]:
    exts = [ 'webm', ]
    for ext in exts:

      foot_pathname = os.path.join(client.slug,show.slug, ext, '%s.%s' % (episode.slug, ext))
      print(os.path.join(os.path.expanduser('~/Videos/veyepar'), foot_pathname))

      if os.path.exists(
          os.path.join(os.path.expanduser('~/Videos/veyepar'), foot_pathname)):

        if settings.MEDIA_URL.startswith('file:/'):
            head=settings.MEDIA_URL
        else:
            # probably no local file access
            # head='http://'+request.META['HTTP_HOST']+settings.MEDIA_URL
            head=settings.MEDIA_URL
            # so review the smaller iPhone file
        item = '/'.join([head, foot_pathname ] )
        writer.writerow([item])


    return response


def play_list(request,show_id,location_slug=None):
    show=get_object_or_404(Show,id=show_id)
    client=show.client
    episodes=Episode.objects.filter(show=show,state=3).order_by('sequence')
    if location_slug:
        episodes = episodes.filter(location__slug=location_slug)

    response = HttpResponse(content_type='audio/mpegurl')
    response['Content-Disposition'] = 'attachment; filename=playlist.m3u'

    writer = csv.writer(response)
    for ep in episodes:
        # pathname = os.path.join( settings.MEDIA_URL,client.slug,show.slug,ext,
        if settings.MEDIA_URL.startswith('file:/'):
            head=settings.MEDIA_URL
            ext='mp4'
        elif settings.MEDIA_URL.startswith('http:/'):
            head=settings.MEDIA_URL
            ext='mp4'
        else:
            # probably no local file access
            head='http://'+request.META['HTTP_HOST']+settings.MEDIA_URL
            # so review the smaller iPhone file
            ext='m4v'
        item = '/'.join([head, client.slug,show.slug,ext, '%s.%s' % (ep.slug, ext)] )
        writer.writerow([item])

    return response

def meet_ical(request,location_id):
    location=get_object_or_404(Location,id=location_id)
    show=location.show
    client=show.client
    episodes=Episode.objects.filter(show=show).order_by('sequence')
    location=episodes[0].location
    return render(request, 'meeting_announcement.html',
        {'client':client,'show':show,
          'location':location,
          'episodes':episodes,
        },
         )

def clients(request):
    # list of clients and a blank to enter a new one

    class Client_Form(ModelForm):
        class Meta:
            model=Client
            fields=('name','slug','tags','description')


    if request.user.is_authenticated():
        if request.method == 'POST':
            # client=Client(sequence=1)
            # form=Client_Form(request.POST,instance=client)
            form=Client_Form(request.POST)
            if form.is_valid():
                form.save()
                return HttpResponseRedirect(
                        reverse(client, args=(form.cleaned_data['slug'],)))
            else:
                pass
                # print form.errors
        else:
            form=Client_Form(initial={'sequence':1})
    else:
        form=None

    clients=Client.objects.annotate(
            max_date=Max('show__episode__start')) \
            .filter(active=True) \
            .order_by('-max_date')

    return render(request, 'clients.html',
        {'clients':clients,
        'client_form':form},
        )


def client(request,client_slug=None):
    # the selected client and
    # list of client's shows and a blank to enter a new show

    client=get_object_or_404(Client,slug=client_slug)

    shows=Show.objects.filter(client=client)\
            .annotate( max_date=Max('episode__start'))\
            .order_by('-max_date')

    class Show_Form(ModelForm):
        class Meta:
            model=Show
            fields=('name','slug','locations','tags','description')

    if request.user.is_authenticated():
        if request.method == 'POST':
            show=Show(client=client,sequence=1,)
            form=Show_Form(request.POST,instance=show)
            if form.is_valid():
                form.save()
                return HttpResponseRedirect(reverse(episodes, args=(client_slug, form.cleaned_data['slug'])))
            else:
                pass
                # print form.errors
        else:


            # locations=Location.objects.filter(active=True).order_by('sequence')
            # I am not sure what a good default is for locations.
            locations=[]

            initial={'client':client.id, 'sequence':1}
            if shows:
                last_show = shows[0]
                initial['name']=last_show.name
                initial['locations']= \
                        last_show.locations.filter(active=True)
                initial['sequence']=last_show.sequence+1

            form=Show_Form( initial=initial )
    else:
        form=None

    return render(request, 'client.html',
        {'client':client,
        'show_form':form,
        'shows':shows},
        )

def locations(request):

    if request.user.is_authenticated():

        if request.method == 'POST':
            location_form=Location_Form(request.POST)

            if location_form.is_valid():
                location_form.save()
            else:
                # print form.errors
                pass
        else:
            location_form=Location_Form(initial={'sequence':1})
    else:
        location_form=None

    locations=Location.objects.order_by('sequence')

    return render(request, 'locations.html',
        {
          'locations':locations,
          'location_form':location_form,
        },
     )

def show_anomalies(request, show_id, ):
    show=get_object_or_404(Show,id=show_id)
    client=show.client

    episodes=Episode.objects.filter(show=show,)
    if "active" in request.GET:
        episodes = episodes.filter(location__active=True)

    max_title_len = max( len(ep.name) for ep in episodes )
    max_authors_len = max( len(ep.authors) for ep in episodes if ep.authors is not None)

    max_name_ep = None
    max_authors_ep = None
    max_name_len = 0
    max_authors_len = 0
    for ep in episodes:
        if len(ep.name) > max_name_len:
            max_name_len = len(ep.name)
            max_name_ep = ep
        if ep.authors is not None and \
                len(ep.authors) > max_authors_len:
            max_authors_len = len(ep.authors)
            max_authors_ep = ep

    dupes = Episode.objects.values('slug').annotate(Count('id')).order_by().filter(id__count__gt=1, show=show)
    dup_eps = Episode.objects.filter(slug__in=[item['slug'] for item in dupes], show=show)

    # if someone starts a video file when the talk starts, that is clean.
    # if they miss the start by so much that some needs to be removed
    #   (thus start=2 min into the start of the file) that is dirty
    episodes=Episode.objects.filter(show=show,state__gt=1)
    clean,dirty = 0,0
    for ep in episodes:
        found=False
        cuts = Cut_List.objects.filter(episode=ep)
        for cut in cuts:
            found = found or cut.start or cut.end
        if found: dirty += 1
        else: clean += 1


    return render(request, 'show_anomalies.html',
        {
          'client':client,
          'show':show,
          'locations':locations,
          'dup_eps':dup_eps,
          'clean':clean, 'dirty':dirty,
          'max_name_ep':max_name_ep,
          'max_authors_ep':max_authors_ep,
          'now':datetime.datetime.now(),
        },
     )

def show_pipeline(request, show_id ):

    show=get_object_or_404(Show,id=show_id)
    client=show.client
    # episodes=Episode.objects.filter(show=show,location__active=True)
    # ep_states = Episode.objects.values('state').annotate(Count('state')).order_by().filter(show=show,location__active=True).order_by('state')

    states = State.objects.all()
    statesl = []
    for s in states:

        ep_states = Episode.objects.values('state').annotate(Count('state')).order_by().filter(show=show,location__active=True, state=s.sequence)

        if ep_states:
            count=ep_states[0]['state__count']
        else:
            count=0

        stated = {
                'sequence':s.sequence,
                'slug':s.slug,
                'description':s.description,
                'count':count }

        statesl.append(stated)

    return render(request, 'show_pipeline.html',
        {
          'client':client,
          'show':show,
          'statesl':statesl,
        },
     )

def show_parameters(request, show_id ):

    show=get_object_or_404(Show,id=show_id)
    client=show.client
    locations=show.locations.filter(active=True).order_by('sequence')
    episodes=Episode.objects.filter(show=show)

    return render(request, 'show_parameters.html',
        {
          'client':client,
          'show':show,
          'locations':locations,
          'episodes':episodes,
        },
     )


def show_stats(request, show_id, ):
    """
    Show Status - varous summaries of rooms, days and the whole thing
    """

    show=get_object_or_404(Show,id=show_id)
    client=show.client
    episodes=Episode.objects.filter(show=show,location__active=True)
    lockeds=Episode.objects.filter(show=show, locked__isnull=False).order_by('locked')
    raw_files=Raw_File.objects.filter(show=show,location__active=True)
    locations=show.locations.filter(active=True).order_by('sequence')

    # needs better organazation.  refactor please.
    empty_stat = {
            'ep':{
               'times': [False] * 24,
               },
               'count':0,'minutes':0,
               'start':None, 'end':None, 'states':[0]*len(STATES),
               'loc':None, 'date':None,
               'raw':{
                   'start':None,
                   'end':None,
                   'times': [False] * 24,
                   },
               'files':0, 'bytes':0,
               }

    # get the range of dates used by this show
    # which is a combonation of scheduled dates and dates of videos
    # there really shouldn't be video files outside the range
    # so those should be cleaned up.
    dates=[]

    for rf in raw_files:
        if rf.start is not None:
            dt = rf.start.date()
            if dt not in dates: dates.append(dt)

    for ep in episodes:
        dt = ep.start.date()
        if dt not in dates: dates.append(dt)

    dates.sort()

    # show totals:
    show_stat = deepcopy(empty_stat)

    # make 3 dicts of empty stats
    # 1. for each room-day (date,loc)
    stats={}
    for loc in locations:
        for dt in dates:
            d = deepcopy(empty_stat)
            d['loc'] = loc
            d['date'] = dt
            stats[(dt,loc.id)] = d

    # 2. for locations:
    d={}
    for loc in locations:
        d[loc.id] = deepcopy(empty_stat)
        d[loc.id]['loc'] = loc
    locations=d

    # 3. for dates:
    d={}
    for dt in dates:
        d[dt] = deepcopy(empty_stat)
    dates=d

    # gather episode stats
    # func to update one:


    def set_times(times,s,e):
        # times: list of bools
        # s,e: start/end datetimes
        sh = s.hour
        eh = (e + datetime.timedelta(minutes=59)).hour # bump up to next h
        times[sh:eh] = [True]*(eh-sh)


    def add_ep_to_stat(ep,stat):

        set_times( stat['ep']['times'], ep.start, ep.end)

        stat['count']+=1
        duration=ep.end-ep.start
        stat['minutes']+=duration.seconds/60
        stat['start']=ep.start if stat['start'] is None else min(stat['start'],ep.start)
        stat['end']=ep.end if stat['end'] is None else max(stat['end'],ep.end)
        if 0<= ep.state <= len(STATES):
            stat['states'][ep.state]+=1
        else:
            stat['states'][0]+=1

        return

    for ep in episodes:
        dt = ep.start.date()
        loc = ep.location.id

        # update grand total:
        add_ep_to_stat(ep,show_stat)

        # update total for date:
        add_ep_to_stat(ep,dates[dt])

        # update total for location:
        add_ep_to_stat(ep,locations[loc])

        # update room-loc
        add_ep_to_stat(ep,stats[(dt,loc)])


    def add_rf_to_stat(rf,stat):
        set_times( stat['raw']['times'], rf.start, rf.end)
        stat['files'] += 1
        stat['bytes'] += rf.filesize

        stat['raw']['start']=rf.start if stat['raw']['start'] is None else min(stat['raw']['start'],rf.start)
        stat['raw']['end']=rf.end if stat['raw']['end'] is None else max(stat['raw']['end'],rf.end)
        return

    # gather raw_file stats
    for rf in raw_files:
        if rf.start is not None:
            dt = rf.start.date()
            loc = rf.location.id

            add_rf_to_stat(rf,show_stat)
            add_rf_to_stat(rf,dates[dt])
            add_rf_to_stat(rf,locations[loc])
            add_rf_to_stat(rf,stats[(dt, loc)])

    # make lists out of the dics cuz I can't figur out how to get at the dict

    # and do some more calcs
    def calc_stat(stat):

        stat['ep']['times_display'] = ''.join(
                'x' if t else 'o' for t in stat['ep']['times'])
        stat['raw']['times_display'] = ''.join(
                'x' if t else 'o' for t in stat['raw']['times'])
        stat['times_display'] = ''.join( {
            (False, False):' ',
            (False, True) :'~',
            (True, False) :'!',
            (True, True)  :'.'}[er] for er in zip(
                stat['ep']['times'], stat['raw']['times']) ).strip()

        stat['hours']=int( stat['minutes']/60.0 + .9)

        stat['talk_gig']=int(stat['minutes']*13/60)
        stat['gig']=stat['bytes']/(1024**3)

        stat['variance'] = stat['talk_gig'] - stat['gig']

        # alarm is % of expected gig, 0=perfect, 20 or more = wtf?
        stat['alarm']= int(
               stat['variance'] / (stat['minutes']/60.0*13 + 1) * 100 )
        if stat['alarm'] > 0: # red
            stat['alarm_color'] = "%02x%02x%02x" % (
                    255, 255-stat['alarm'], 255-stat['alarm'] )
        else: # yellow
            # 250, 255, 189
            stat['alarm_color'] = "%02x%02x%02x" % (
                    255, 255, 255 + stat['alarm'] )
        return stat

    show_stat = calc_stat(show_stat)
    l = []
    for dt in dates:
        d = dates[dt]
        d['date'] = dt
        d = calc_stat(d)
        l.append(d)
    l.sort(key=operator.itemgetter('date'))
    dates=l
    # pprint(dates)

    l = []
    for loc in locations:
        d = locations[loc]
        d['seq'] = d['loc'].sequence
        d = calc_stat(d)
        l.append(d)
    l.sort(key=operator.itemgetter('seq'))
    locations=l
    # pprint(locations)

    rows=[]
    for dt in dates:
        dt=dt['date']
        row=[]
        for loc in locations:
            stat = calc_stat(stats[(dt,loc['loc'].id)])
            row.append((stat,loc))
        rows.append(row)

    states = list(zip( show_stat['states'], STATES))
    rows = list(zip(dates,rows))

    return render(request, 'show_stats.html',
        {
          'client':client,
          'show':show,
          'locations':locations,
          'show_stat':show_stat,
          'rows':rows,
          'states':states,
          'locked':lockeds,
        },
     )


def processes(request, show_id, ):
    """
    What is locked, so should be being worked on.
    """

    show=get_object_or_404(Show,id=show_id)
    client=show.client
    lockeds=Episode.objects.filter(show=show, locked__isnull=False).order_by('locked')

    return render(request, 'processes.html',
        {
          'client':client,
          'show':show,
          'locked':lockeds,
        },
     )

def raw_file(request, raw_file_id):

    rf=Raw_File.objects.get(id=raw_file_id)
    eps = scheduled_episodes(rf)
    # Raw_File.objects.filter(cut_list__episode=episode)
    # eps = Episode.objects.filter(cut_list__raw_file=rf)

    return render(request, 'raw_file.html',
        {
          'raw_file':rf,
          'eps':eps,
           'exts':settings.UPLOAD_FORMATS,
        },
         )

def rf_set(request, location_slug):
    # Show files collected for a given location and date
    # aka a set, corisponds to a set of recording sheets.

    location = Location.objects.get(slug=location_slug)

    rfs=Raw_File.objects.filter(
            location=location).order_by('start')

    if "start_date" in request.GET:
        start_date=request.GET['start_date']
        rfs=rfs.filter(start__startswith=start_date)

    trash = None
    if "trash" in request.GET:
        trash=request.GET['trash'].lower()=="y"
        rfs=rfs.filter(trash=trash)

    rf_cls=[]
    for rf in rfs:
        # eps = scheduled_episodes(rf)
        cls = rf.cut_list_set.all()
        rf_cls.append([rf,cls])

    return render(request, 'raw_set.html',
        {
          'trash':trash,
          'location':location,
          'rf_cls':rf_cls,
        },
         )


def raw_file_audio(request):
    """
    visulation of audio for a room-day of talks
    template will group files one hour per row
    """

    # there better be a show_id
    show = Show.objects.get(id=request.GET['show_id'])
    locations=Location.objects.filter(show=show)

    if "active" in request.GET:
        locations=locations.filter(active=True)
    if "location_slug" in request.GET:
        locations=locations.filter(slug=request.GET['location_slug'])

    rfs=Raw_File.objects.filter(show=show,
            trash=False,
            location__in=locations,
            ).order_by('start')

    if "start_date" in request.GET:
        start_date=request.GET['start_date']
        rfs=rfs.filter(start__startswith=start_date)

    # pull out the hour so the template can group on it
    rf_audios=[]
    for rf in rfs:
        rf_audio={'rf':rf,
                'hour':rf.start.hour,
                }
        rf_audios.append(rf_audio)

    # find the previous and next room-day
    # for now assume there are locations
    location = locations[0]

    # get previous location
    locations=Location.objects.filter(
            show=show,
            sequence__lt=location.sequence,
            ).order_by('-sequence',)[:1]

    if locations:
        prev_location = locations[0]
    else:
        prev_location = None

    # get next location
    locations=Location.objects.filter(
            show=show,
            sequence__gt=location.sequence,
            ).order_by('sequence',)[:1]

    if locations:
        next_location = locations[0]
    else:
        next_location = None


    return render(request, 'raw_file_audio.html',
        {
          'show':show,
    #      'start_date':start_date,
          'prev_location':prev_location,
          'location':location,
          'next_location':next_location,
          'rf_audios':rf_audios,
        },
         )


def final_file_audio(request):

    show = Show.objects.get(id=request.GET['show_id'])
    client=show.client
    episodes=Episode.objects.filter(show=show,).order_by('start')

    state = request.GET.get('state')
    if state is not None:
        episodes=episodes.filter(state=state)

    epid = request.GET.get('epid')
    if epid is not None:
        episodes=episodes.filter(id=epid)

    return render(request, 'final_file_audio.html',
        {
          'client':client,
          'show':show,
          'episodes':episodes,
          'exts':settings.UPLOAD_FORMATS,
        },
         )


def orphan_img(request, show_id, ):

    show=get_object_or_404(Show,id=show_id)
    client=show.client

    # dupes = Episode.objects.values('slug').annotate(Count('id')).order_by().filter(id__count__gt=1, show=show)

    AddImageToEpFormSet = formset_factory(AddImageToEp, extra=0)
    if request.user.is_authenticated():
        if request.method == 'POST':
            formset = AddImageToEpFormSet(request.POST)
            for form in formset:
                if form.is_valid():
                    episode_ids = form.cleaned_data['episode_ids']
                    if episode_ids is not None:
                        for episode_id in episode_ids.split():
                            img = get_object_or_404(Image_File,
                                    id=form.cleaned_data['image_id'])
                            episode = get_object_or_404(Episode,id=episode_id)
                            img.episodes.add(episode)
                        # I wonder how this should get handled
                        # form.errors

    orphan_images = Image_File.objects.annotate(
            Count("episodes")).filter(show=show,episodes__count=0)

    init = [{'image_id':img.id,} for img in orphan_images]
    formset = AddImageToEpFormSet(initial=init)

    return render(request, 'imgs.html',
            {
          'client':client,
          'show':show,
          'imgsfs':list(zip(orphan_images,formset.forms)),
          'iefs':formset,
          },
         )


def title_slides(request, show_id, ):

    show=get_object_or_404(Show,id=show_id)
    client=show.client

    # episodes=Episode.objects.filter(show=show,
    #    location__active=True)
    # .exclude(emails='')

    kwargs = {
            "show": show,
            "location__active": True,
            # "emails": request.GET['emails'],
            # "show__client__slug": request.GET['client'],
            # "show__slug": request.GET['show'],
            # "": request.GET[''],
            }

    if "state" in request.GET:
        kwargs["state"] = request.GET['state']

    # if "active" in request.GET:
    #    kwargs["location__active"] = request.GET['active'].lower() == "true"

    episodes=Episode.objects.filter(**kwargs).order_by(
            'location',
            'start',
            )

    return render(request, 'title_slides.html',
            {
          'client':client,
          'show':show,
          'episodes':episodes,
          },
         )

def episodes_script(request, script=None):

    kwargs = {
            "show__client__slug": request.GET['client'],
            # "show__slug": request.GET['show'],
            # "state": request.GET['state'],
            # "": request.GET[''],
            }

    # print kwargs

    episodes=Episode.objects.filter(**kwargs).order_by('start')

    # episodes=Episode.objects.filter(show__slug="fosdem_2014", state='5').order_by('start')
    print(len(episodes))

    response = render(request, 'episodes_script.txt',
            { 'episodes':episodes,
                'script':script,
            },
            content_type="text/plain",
            )

    response['Content-Disposition'] = 'filename={0}.sh'.format( script )

    return response


def episode_assets(request, episode_id):
    """
    returns a list of URLs of the assets (in preview form)
    and the .mlt and .sh
    """

    assets=[]

    episode=get_object_or_404(Episode,id=episode_id)
    slug = episode.slug
    show=episode.show
    client=show.client
    lq_ext="mp4"

    # the base of the URLs
    head=settings.MEDIA_URL
    show_url = os.path.join(head,client.slug,show.slug)

    wget="wget -N --force-directories"
    # assets.append( "wget -N --force-directories -i http://" + request.META['HTTP_HOST'] + request.get_full_path() )

    assets.append( "{} {}/mlt/{}.mlt".format(wget,show_url,slug) )
    # assets.append( "{} {}/tmp/{}.sh".format(wget,show_url,slug) )
    assets.append( "{} {}/titles/{}.png".format(wget,show_url,slug) )
    assets.append( "{} {}/titles/{}.svg".format(wget,show_url,slug) )
    assets.append( "{} {}/assets/{}".format(wget,show_url, client.credits) )

    # add the raw files
    cuts = Cut_List.objects.filter(episode=episode).order_by('sequence', 'raw_file__start')
    if request.GET.get('apply') == 'yes':
        cuts = cuts.filter(apply=True)

    rfs = Raw_File.objects.filter(cut_list__in=cuts).distinct()
    if rfs:

        for rf in rfs:
            assets.append( "{} {}/dv/{}/{}.{}".format(wget, show_url,
                rf.location.slug, rf.filename, lq_ext ) )

        # make symlinks from epected filename to smaller webm
        show_path = urllib.parse.urlparse(show_url)
        first_dir = '"{}{}/dv/{}/{}"'.format( show_path.netloc, show_path.path,
                rf.location.slug,
                os.path.split(rf.filename)[0])

        assets.append("cd " + first_dir)
        for rf in rfs:
            rf_filename = os.path.split(rf.filename)[1]
            assets.append( "ln -s {rf_filename}.{lq_ext} {rf_filename}".format(rf_filename=rf_filename, lq_ext=lq_ext) )

    response = HttpResponse('\n'.join(assets), content_type="text/plain")
    response['Content-Disposition'] = \
            'inline; filename={}.sh'.format(slug)

    return response



def episode_list(request, state=None):

    states = State.objects.all()

    episodes=Episode.objects.filter(state=state, show__active=True).order_by('start')

    if "show" in request.GET:
        episodes = episodes.filter( show__slug=request.GET['show'] )

    return render(request, 'episode_list.html',
            { 'episodes':episodes,
                'states':states,
        },
         )


def episodes(request, client_slug=None, show_slug=None, location_slug=None,
              start_day=None, state=None):

    client=get_object_or_404(Client,slug=client_slug)
    show=get_object_or_404(Show,client=client,slug=show_slug)

    location_slug = location_slug if location_slug \
            else request.GET.get('location_slug')

    start_date = request.GET.get('date')

    cuts = request.GET.get('cuts')
    emails = request.GET.get('emails')
    comment = request.GET.get('comment')
    released = request.GET.get('released')
    images = request.GET.get('images')
    log_has = request.GET.get('log_has')

    order_by = request.GET.get('order_by')

    if "state" in request.GET:
        state = request.GET.get('state')

    locations=show.locations.filter(active=True).order_by('sequence')
    episodes=Episode.objects.filter(show=show)

    admin_params="show__id__exact=%s" % show.id

    if location_slug:
        # location here is for default location for new episodes
        location=get_object_or_404(Location,slug=location_slug)
        episodes=episodes.filter(location=location)
        admin_params += "&location__id__exact=%s" % location.id
    else:
        episodes=episodes.filter(location__active=True)

    if start_date:
        episodes = episodes.filter(start__startswith=start_date)
        admin_params +="&start__date=%s" % start_date
    if start_day:
        episodes = episodes.filter(start__day=start_day)
        admin_params +="&start__day=%s" % start_day
    if state:
        episodes = episodes.filter(state=state)
        admin_params += "&state__exact=%s" % state
      #   if state=='0':
      #  episodes = episodes.filter(state__isnull=True)

    if cuts:
        if cuts=="0":
            # only show episodes with no raw files found
            episodes = episodes.filter(cut_list__isnull=True)
        else:
            # that have cuts cuts or more cuts
            episodes = episodes.annotate(
                    c=Count("cut_list")).filter(c__gte=cuts)

    if emails:
        episodes = episodes.exclude(emails="")

    if comment:
        episodes = episodes.exclude(comment="")

    if released:
        episodes = episodes.filter(released=True)


    if images:
        if images=="0":
            # only show episodes with no raw files found
            episodes = episodes.filter(image_file__isnull=True)
        else:
            # episodes = episodes.filter(image_file__isnull=False)
            episodes = episodes.annotate(
                    c=Count("image_file")).filter(c__gte=images)

    if log_has:
        # track down eisode's that were encoded on box X
        episodes = episodes.filter(log__result=log_has).distinct()

    if order_by:
        if order_by == "location,start":
            episodes = episodes.order_by('location__sequence','start')
    else:
        episodes = episodes.order_by('start')

    if request.user.is_authenticated():
        if request.method == 'POST':
            form=Episode_Form_Preshow(request.POST)
            if form.is_valid():
                episode = form.save()
                # setup next form
                # use saved Episode as a base for defaults
                if episode.sequence is None:
                    sequence=2
                else:
                    print(episode.sequence)
                    sequence=episode.sequence+1
                inits={
                    'show':show.id,
                    'location':episode.location.id,
                    'sequence':sequence,
                    'start':episode.end + datetime.timedelta(minutes=5),
                    'duration':episode.duration,
                    'state':1,
                    }
                # roll the new episode into the query set
            else:
                # print form
                inits=None # (prevents form from being created below)
        else:
            if episodes:
                # use last Episode as a base for defaults
                episode = episodes[len(episodes)-1]
                print(episode)
                location = episode.location.id
                if episode.sequence is None:
                    sequence = 2
                else:
                    sequence = episode.sequence+1
                start = episode.end
            else:
                # first Episode of the show
                print("locations", locations)
                if locations:
                    location = locations[0].id
                sequence = 1
                # today at 6pm
                start = datetime.datetime.combine(
                            datetime.date.today(),datetime.time(18))
            inits = {
                'show':show.id,
                # 'location':location,
                'sequence':sequence,
                'start': start,
                'duration':'00:45:00',
                'state':1,
            }
        if inits:
            form=Episode_Form_Preshow(initial=inits, locations=locations)
    else:
        # set this so 'episode_form':form doesn't blow up
        # there are other ways of doing this, they suck too.
        form = None

    query_params = request.GET.copy()
    query_params['client'] = client.slug
    query_params['show'] = show.slug
    # query_params[''] =

    if state is not None:
        query_params['state'] = state

    # return render(request, 'show.html',
    return render( request, 'show.html',
        {'client':client,'show':show,
          'locations':locations,
          'location_slug':location_slug,
          'episodes':episodes,
          'episode_form':form,
          'admin_params':admin_params,
          'query_params':query_params.urlencode(),
          'now':datetime.datetime.now(),
        },
        )
        #  )


def train(request,episode_id, episode_slug, edit_key):

    episode=get_object_or_404( Episode, id=episode_id )

    return render(request, "approve/train.html",
                    { 'episode':episode, },
                     )


def approve_episode(request,episode_id, episode_slug, edit_key):
    """
    Allow someone to approve a video
    Lets hope that the edit_key does not get abused.
    """
    episode=get_object_or_404( Episode, id=episode_id )

    if request.method == 'POST':
            episode.locked = datetime.datetime.now()

    who=None ## for the cases that don't use the who form

    if episode.edit_key == edit_key:
        if episode.state == 8: # review_2 -  TODO use state.slug?
            if request.method == 'POST':
                who = Who(request.POST)
                if who.is_valid():
                    episode.locked_by = who.cleaned_data['locked_by']
                    state = State.objects.get(sequence=episode.state)
                    log=Log(episode=episode,
                        state=state,
                        ready = datetime.datetime.now(),
                        start = datetime.datetime.now(),
                        end = datetime.datetime.now(),
                        result = episode.locked_by )
                    log.save()
                    episode.state += 1
                    episode.save()
                    template = 'approved'

            else:
                who = Who()
                template = "approve"

        elif episode.state == 1: # edit -  TODO use state.slug?
                # give the reviewer the Approve button
                template = "edit"
        else:

            # not in review 2 state
            # likely someone else already approved it
            template = "not_ready"

    else:
        # bad key
        # who knows what is going on here.
        template = "bad_key"


    return render(request, "approve/%s.html"%template,
                    { 'episode':episode,
                        'who':who,
                    },
                     )

def overlapping_files(request,show_id):

    show=get_object_or_404(Show,id=show_id)
    client=show.client
    raw_files=Raw_File.objects.raw(
            '''select distinct r1.* from main_raw_file r1, main_raw_file r2
            where r1.id != r2.id
            and not r1.trash
            and r1.start<r2.end and r1.end>r2.start
            and r1.location_id=r2.location_id
            and r1.filesize=r2.filesize
            and r1.show_id=%s and r2.show_id=%s
            order by r1.location_id, r1.start, r1.filename, r1.filesize''', [show.id,show.id])

    rlist=[r.__dict__ for r in raw_files]

    start,end=24*60,0
    for r in rlist:

        r['location']=Location.objects.get(id=r['location_id'])
        r['show']=Show.objects.get(id=r['show_id'])
        r['client']=r['show'].client

        r['locdate'] = "%s - %s " % (
                r['location'],  r['start'].strftime("%Y%b%d") )
        r['start_min']=r['start'].hour*60+r['start'].minute
        r['end_min']=r['end'].hour*60+r['end'].minute
        if r['start_min'] < start: start = r['start_min']
        if r['end_min'] > end: end = r['start_min']
        if r['filename'][-5:] in ['-1.dv','-2.dv']:
            r['trash'] = True
            rf = Raw_File.objects.get(id=r['id'])
            rf.trash = True
            # rf.save()

    width_min = end-start

    width_px=300.0
    x=width_min/width_px +1 ## float math so that x isn't an int
    for r in rlist:
        r['start_px']=int((r['start_min']-start)/x)
        r['end_px']=int((r['end_min']-start)/x)
        r['width_px']=(r['end_px']-r['start_px'])

    return render(request, 'overlapping_raw_files.html',
        {
          'rfs':rlist,
        },
             )


def overlapping_episodes(request,show_id):

    show=get_object_or_404(Show,id=show_id)
    client=show.client
    episodes=Episode.objects.raw('select distinct e1.* from main_episode e1, main_episode e2 where e1.id != e2.id and e1.start<e2.end and e1.end>e2.start and e1.location_id=e2.location_id and e1.show_id=%s and e2.show_id=%s order by e1.location_id, e1.start', [show.id,show.id])
    elist=[e.__dict__ for e in episodes]
    start,end=24*60,0
    for e in elist:
        e['location']=Location.objects.get(id=e['location_id'])
    start,end=24*60,0
    for e in elist:
        e['start_min']=e['start'].hour*60+e['start'].minute
        e['end_min']=e['end'].hour*60+e['end'].minute
        if e['start_min'] < start: start = e['start_min']
        if e['end_min'] > end: end = e['start_min']
    width_min = end-start

    width_px=300.0
    x=width_min/width_px +1 ## float math so that x isn't an int
    for e in elist:
        e['start_px']=int((e['start_min']-start)/x)
        e['end_px']=int((e['end_min']-start)/x)
        e['width_px']=(e['end_px']-e['start_px'])

    return render(request, 'overlapping_episodes.html',
        {
          'episodes':elist,
        },
             )

def mini_conf(request):

    show_id = request.GET.get('show_id')
    show=get_object_or_404(Show,id=show_id)
    client=show.client

    kwargs = {
            "show": show,
            "location__active": True,
            # "emails": request.GET['emails'],
            # "show__client__slug": request.GET['client'],
            # "show__slug": request.GET['show'],
            # "state": request.GET['state'],
            # "": request.GET[''],
            }

    day = request.GET.get('day')
    if day is not None:
        kwargs['start__day']=day

    episodes=Episode.objects.filter(**kwargs).order_by(
            'location',
            'start',
            )

    magic = request.GET.get('magic')
    print((day,magic))
    good12 = [379,380] # Case 2 & 3
    good13 = [376,378,379,380]
    if magic == '1':
        episodes = episodes.exclude(
                start__day=12,location__in=good12)
        episodes = episodes.exclude(
                start__day=13,location__in=good13)
    elif magic == '2':
        if day == "12":
            print("here 2,12 ")
            episodes = episodes.filter(location__in=good12)
        else:
            episodes = episodes.filter(location__in=good13)

    return render(request, 'mini_conf.html',
        {
          'episodes':episodes,
        },
             )


def scheduled_episodes(rf):
    # find episodes that overlap the file

    eps = Episode.objects.filter(
        Q(start__lte=rf.end)|Q(start__isnull=True),
        Q(end__gte=rf.start)|Q(end__isnull=True),
        location=rf.location)

    return eps


def mk_episode(request,show_id):
    """
    raw files... gonna make a video out of air.
    """

    def find_start_end(markpicker_formset):
        # find the first and last [x]Apply marks

        found_start,applied = False,False

        for mark in markpicker_formset:
            click=datetime.datetime.strptime(
                      mark.cleaned_data['click'],'%Y-%m-%d %H:%M:%S')
            apply=mark.cleaned_data['apply']

            if not found_start and apply:
                # found first [x]Apply, use it, stop looking.
                start=click
                found_start=True

            if applied:
                # if the previous mark was applied,
                # maybe this is the end.
                end=click
            # save current apply for next iteration
            applied = apply

        return start,end


    show=get_object_or_404(Show,id=show_id)
    # client = show.client


    MarkPicker_FormSet = formset_factory(MarkPicker, extra=0)

    if request.user.is_authenticated():

        if request.method == 'POST':

            episode_form=Episode_Form_Mini(request.POST)
            markpicker_formset = MarkPicker_FormSet(request.POST)

            if episode_form.is_valid() \
              and markpicker_formset.is_valid():

                start,end = find_start_end(markpicker_formset)

                print(start,end)

                episode = episode_form.save(commit=False)

                episode.show = show
                locations=show.locations.filter(
                        active=True).order_by('sequence')
                episode.location = locations[0]
                episode.start = start
                episode.end = end
                episode.save()
                mk_cuts(episode)

            else:
                print(episode_form.errors)
                print(markpicker_formset.errors)

        else:
            # new form
            init = {
                'name':'t1',
                }
            episode_form = Episode_Form_Mini(init)

            marks = Mark.objects.filter(show=show).order_by('click')
            init = [ {
                'apply':False,
                'click':mark.click.strftime('%Y-%m-%d %H:%M:%S'),
                } for mark in marks]
            # guess ... 2nd to last should be it.
            init[-2]['apply']=True
            markpicker_formset = MarkPicker_FormSet(initial=init)

    else:
        episode_form = None
        markpicker_formset = None

    return render(request, 'mk_episode.html',
            {
                'episode_form':episode_form,
                'markpicker_formset':markpicker_formset,
            },
         )



def orphan_dv(request,show_id):
    """
    dv files that are not associated with an episode.
    """

    # http://localhost:8080/main/orphan_dv/173/?format=m3u&trash=y

    format = request.GET.get('format')
    trash = request.GET.get('trash')

    size = request.GET.get('size')

    show=get_object_or_404(Show,id=show_id)
    client = show.client

    rfs=Raw_File.objects.filter(show=show).order_by('start')
    if trash is not None:
        if trash.lower() == 'n':
            rfs=rfs.filter(trash=False)
        if trash.lower() == 'y':
            rfs=rfs.filter(trash=True)

    if size is not None:
        rfs=rfs.filter(filesize__ge=size)

    orphans=[]
    for rf in rfs:
        if rf.cut_list_set.count()==0:
            eps = scheduled_episodes(rf)
            orphans.append([rf,eps])

    if format is None:
        return render(request, 'orphan_dv.html',
            { 'rfs':orphans,
               'exts':settings.UPLOAD_FORMATS,
                },
             )
    elif format == 'json':
        pass
    elif format == 'm3u':

        response = HttpResponse(content_type='audio/mpegurl')
        response['Content-Disposition'] = 'inline; filename=playlist.m3u'
        writer = csv.writer(response)
        head="~/Videos/veyepar"
        for orphan in orphans:
            rf = orphan[0]
            pathname = os.path.join(head,client.slug,show.slug, 'dv',
                rf.location.slug, rf.filename )
            writer.writerow([pathname])

        return response

def episode_chaps(request, episode_id):

    episode=get_object_or_404(Episode,id=episode_id)
    cuts = Cut_List.objects.filter(
            episode=episode).order_by('sequence','raw_file__start','start')

    # start times of chapters (included cuts)
    start_chap = "00:00"
    chaps,total_time = [],0
    for cut in cuts:
        if cut.apply:

            h,m,s = (total_time//3600,
                    (total_time%3600)//60,
                    total_time%60)
            if episode.cuts_time() < 3600:
                # start_chap = "%s:%02i:%02i" % (h,m,s)
                start_chap = "{m:02d}:{s:02d}".format(h=h,m=m,s=s)
            else:
                start_chap = "{h}:{m:02d}:{s:02d}".format(h=h,m=m,s=s)

            yt ="{yt}?t={h}h{m}m{s}s".format(
                    yt=episode.host_url,h=h,m=m,s=s)

            cut_duration = cut.duration() // 60
            if cut_duration:
                mins = "{} min".format(cut_duration)
            else:
                mins = ""

            chaps.append((start_chap,cut,yt,mins))

            # setup for next chapter
            # start_chap=end_chap
            total_time+=int(cut.duration()) # durration is in seconds

        else:
            chaps.append(('',''))

    return render(request, 'episode_chaps.html',
        {'episode':episode,
         'chaps':chaps,
        },
         )



def mk_cuts(episode,
        short_clip_time = 0,
        start_slop=0, end_slop=0):

    """
    short_clip_time - threshold for the person kinda maybe starts talking and doesn't.  cut, cut, cut = small clips that need to be discarded.
    so include them in the time window, but default to not included.

    start/end slop - minutes time added to the start/end of the schedule to accommodate talks not starting or ending on time.

    """

    # start,end of talk bracket to look for video data:
    # slop goes out from the talk, offset shifts.. so math.

    start = episode.start - datetime.timedelta(minutes=start_slop)
    end = episode.end + datetime.timedelta(minutes=end_slop)

    location=episode.location
    # print("loc offset", location.hours_offset)
    if location.hours_offset is not None:
        start += datetime.timedelta( hours = location.hours_offset )
        end += datetime.timedelta( hours = location.hours_offset )

    print("start:",start, start.__repr__())
    print("end:",end, end.__repr__())

# start: 2016-07-16 10:00:00
# end: 2016-07-16 10:25:00

    # Get the overlapping dv,
    rfs = Raw_File.objects.filter(
            end__gte=start,
            start__lte=end,
            location=episode.location).order_by('start')

    print(rfs)

    seq=100
    started=False ## magic to figure out when talk really started
    for rf in rfs:
        print("rf s:{}  e{}".format(rf.start, rf.end))
        seq+=10
        if (seq>100 and rf.get_minutes() > short_clip_time) or \
              episode.start == rf.start:
            # never pre-select the first clip.
            # unless it starts at the exact time
            # handles start time entered after the fact.
            # and if it is the only clip...
            # (doesn't apply to vocto/cuts)
            # started = True
            pass

        cl,created = Cut_List.objects.get_or_create(
            episode=episode,
            raw_file=rf)

        if created:
            cl.sequence=seq
            # If there is only one segment, use it.
            # (this no longer applies to vocto/cuts
            # else:
            # if the talk has started,
            # and there isn't something wrong with the raw
            # (like it is a dupe, or lunch)
            # and the segment is in the time slot
            apply = started \
                and not rf.trash \
                and (rf.start < episode.end)
            cl.apply = apply

            # if there are mark clicks,
            #   break the current file into more cuts
            marks = Mark.objects.filter(
                    location=episode.location,
                    click__gte = rf.start, click__lte = rf.end
                        ).order_by('click')
            apply=True
            for mark in marks:
                print("mark:{}".format(mark))
                seq+=10
                # dif is offset from start, in and out points
                dif = mark.click - rf.start
                end = dif.total_seconds()
                print('end: {}'.format(end))
                cl.end = end
                cl.save()

                start = end
                cl,created = Cut_List.objects.get_or_create(
                    episode=episode,
                    raw_file=rf,
                    start = start,
                    )
                print("cl,created: {},{}".format(cl,created))
                if created:
                    cl.sequence=seq
                    cl.apply = episode.start <= mark.click < episode.end
                            # datetime.timedelta(minutes=end_slop))
                    started = cl.apply

            cl.save()

    return Cut_List.objects.filter(episode=episode).order_by('sequence','raw_file__start')


def episode(request, episode_id, episode_slug=None, edit_key=None):

    episode=get_object_or_404(Episode,id=episode_id)
    show=episode.show
    location=episode.location
    client=show.client

    email_eps = None
    if request.user.is_authenticated():
        if not episode.emails and episode.authors:

            # mine emails
            email_eps = []
            for author in episode.authors.split(','):
                email_eps.extend( Episode.objects.filter(
                    authors__icontains = author.strip(),
                    ).exclude( emails='', ))
    else:
        # hide emails if user is not logged n
        episode.emails = None

    try:
        # why Start/End can't be null:
        # http://code.djangoproject.com/ticket/13611
        # prev_episode = episode.get_previous_by_start(show=show)
        prev_episode = episode.get_previous_by_start(
                show=show, location=location)
    except Episode.DoesNotExist:
        # at edge of the set of nulls or values.
        prev_episode = None

    try:
        next_episode = episode.get_next_by_start(
                show=show, location=location)
    except Episode.DoesNotExist:
        next_episode = None

    cuts = Cut_List.objects.filter(
            episode=episode).order_by('sequence','raw_file__start','start')

    # If this episode is still being edited, create or add cuts
    # if episode.state==1:
    # This didn't work, put back the "only if empty"
    if not cuts:
        cuts = mk_cuts(episode, start_slop=5)

    if cuts:
        offset = abs( cuts[0].raw_file.start - episode.start )
    else:
        offset = None


    clrfFormSet = formset_factory(clrfForm, extra=0)
    if request.method == 'POST' and \
            (request.user.is_authenticated() or
                    episode.edit_key == edit_key):

        episode_form = Episode_Form_small(request.POST, instance=episode)
        clrfformset = clrfFormSet(request.POST)
        add_cutlist_to_ep = Add_CutList_to_Ep(request.POST)

        if episode_form.is_valid() \
              and clrfformset.is_valid() \
              and add_cutlist_to_ep.is_valid():
            episode_form.save()
            for form in clrfformset.forms:
                cl=get_object_or_404(Cut_List,id=form.cleaned_data['clid'])

                cl.raw_file.trash=form.cleaned_data['trash']
                cl.raw_file.comment=form.cleaned_data['rf_comment']
                cl.raw_file.save()

                cl.sequence=form.cleaned_data['sequence']
                cl.start=form.cleaned_data['start']
                oend = cl.end # used for splitting
                cl.end=form.cleaned_data['end']
                cl.apply=form.cleaned_data['apply']
                cl.comment=form.cleaned_data['cl_comment']
                cl.save()

                if form.cleaned_data['split']:
                    # copy the current cut list.
                    # this gives 2 pointers to the same Raw File
                    # keep the original .end and move the new end to the start.
                    cl.id=None
                    cl.start = cl.end
                    cl.end = oend
                    cl.sequence+=1
                    cl.save(force_insert=True)

            if add_cutlist_to_ep.cleaned_data['getit']:
                rf_filename = add_cutlist_to_ep.cleaned_data['rf_filename']
                sequence = add_cutlist_to_ep.cleaned_data['sequence']
                rfs = Raw_File.objects.filter(filename=rf_filename)
                for rf in rfs:
                    cl = Cut_List.objects.create(
                        episode=episode,
                           raw_file=rf,
                           apply = True,
                           sequence = sequence, )
                    cl.save()
                    sequence +=10


            # get current data and load into forms

            cuts = Cut_List.objects.filter(
                episode=episode).order_by(
                        'sequence', 'raw_file__trash','raw_file__start')

            init = [{'clid':cut.id,
                'trash':cut.raw_file.trash,
                'sequence':cut.sequence,
                'start':cut.start, 'end':cut.end,
                'apply':cut.apply,
                'cl_comment':cut.comment, 'rf_comment':cut.raw_file.comment,
                 } for cut in cuts]
            clrfformset = clrfFormSet(initial=init)

        else:
            # pass
            print("ep errors:", episode_form.errors)
            print("clrf errors:", clrfformset.errors)
            print("add cut.. errors:", add_cutlist_to_ep.errors)
            for e in add_cutlist_to_ep.errors:
                print(e)
    else:
        episode_form = Episode_Form_small(instance=episode)
        # init data with things in the queryset that need editing
        # this part seems to work.
        init = [{'clid':cut.id,
                'trash':cut.raw_file.trash,
                'sequence':cut.sequence,
                'start':cut.start, 'end':cut.end,
                'apply':cut.apply,
                'cl_comment':cut.comment, 'rf_comment':cut.raw_file.comment,
        } for cut in cuts]
        clrfformset = clrfFormSet(initial=init)

    # start times of chapters (included cuts)
    start_chap = (0,"00:00") # frame, timestamp
    chaps,frame_total = [],0
    for cut in cuts:

        if cut.apply:
            frame_total+=int(cut.duration())
            end_chap = (int(frame_total*29.27), "%s:%02i:%02i" %
              (frame_total//3600, (frame_total%3600)//60, frame_total%60) )
            chap = [start_chap,end_chap]
            # setup for next chapter
            start_chap=end_chap
        else:
            chap = ['','']

        chap.append(cut)

        wall_start = cut.raw_file.start \
                + datetime.timedelta(seconds = cut.get_start_seconds())
        wall_end = cut.raw_file.start \
                + datetime.timedelta(seconds = cut.get_end_seconds())
        chap.append((wall_start,wall_end,))

        chaps.append(chap)

    # default to next Raw_File
    rf_filename = ''
    seq = 10 ## 10 gives it room for shuffling
    if cuts:
        ## use cut left over from somewhere above.  should work.
        seq = cut.sequence + 10
        next_rf = next(cut.raw_file)
        if next_rf is not None:
            rf_filename = next_rf.filename

    add_cutlist_to_ep=Add_CutList_to_Ep(
            initial = {'sequence':seq,
                    'rf_filename':rf_filename, })

# If all the dates are the same, don't bother displaying them
    if episode.start is None or episode.end is None:
      same_dates = False
    else:
      talkdate = episode.start.date()
      same_dates = talkdate==episode.end.date()
      for cut in cuts:
        same_dates = same_dates and \
            talkdate==cut.raw_file.start.date()==cut.raw_file.end.date()

    return render(request, 'episode.html',
        {'episode':episode,
        'email_eps': email_eps,
        'offset':offset,
        'chaps':chaps,
        'client':client, 'show':show, 'location':location,
        'prev_episode':prev_episode,
        'next_episode':next_episode,
        'same_dates':same_dates,
        'episode_form':episode_form,
        'clrffs':list(zip(cuts,chaps,clrfformset.forms)),
        'clrfformset':clrfformset,
        'add_cutlist_to_ep':add_cutlist_to_ep,
        'exts':settings.UPLOAD_FORMATS,
        },
         )

def episode_logs(request, episode_id):
    print(episode_id)
    episode = get_object_or_404(Episode, id=episode_id)
    logs = episode.log_set.order_by('start')
    return render(request, 'episode_logs.html',
        {'episode':episode,
         'logs':logs,
        },
        )


def claim_episode_lock(request, episode_id):
    assert request.user.is_authenticated()

    episode = get_object_or_404(Episode, id=episode_id)

    episode.locked = datetime.now()
    episode.locked_by = request.user.username
    episode.save()

    return HttpResponseRedirect(
        reverse(
            'episode_list',
            kwargs={
                'client_slug': episode.show.client.slug,
                'show_slug': episode.show.slug}))

