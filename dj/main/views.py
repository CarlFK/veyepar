from django.shortcuts import render_to_response, get_object_or_404
from django.contrib.auth import authenticate, login
from django.contrib.auth.models import User, Group
from django.contrib.auth.decorators import login_required
from django.template import RequestContext
from django.template import Context, loader

from django.core.paginator import Paginator, InvalidPage, EmptyPage, PageNotAnInteger
from django.conf import settings

from django import forms
from django.forms import ModelForm
from django.forms.formsets import formset_factory

from django.db.models import Q
from django.db.models import Count,Max

from django.http import HttpResponse, HttpResponseRedirect, Http404
from django.core import serializers
from django.core.urlresolvers import reverse
from django.core.mail import get_connection, EmailMessage

# from django.utils import simplejson

import datetime
import os
import csv
from copy import deepcopy

from io import BytesIO
from pprint import pprint
import operator

import urllib.parse

from main.models import \
        Client, Show, Location, Episode, Cut_List, Raw_File,\
        State, Image_File,Log ,Mark

from main.models import STATES, ANN_STATES
from main.forms import Episode_Form_small, Episode_Form_Preshow, clrfForm, Add_CutList_to_Ep, Who, AddImageToEp

from accounts.forms import LoginForm



def make_test_data(
        title="Test Episode", 
        start_time=datetime.datetime(2010,5,21,0,0,4)):

    # start_time
    # datetime matches what run_tests.sh uses to create files.
    # the scheduled start time is at 4 seconds
    # in the middle of the 2nd clip
    # t=datetime.datetime(2010,5,21,0,0,4)

    desc = """
Sample files and episode:  
file 0 and 4 are outside the range
file 1 and 3 are overlap the episode start/end
file 2 inside the start/end
e=episode,r=raw files
time: 0  1  2  3  4  5  6  7
raws:  00 11111 22 33333 44
episode:     XXXXXXXXX
"""

    # get/create a location, client and show.
    # append additional episodes 

    loc,create = Location.objects.get_or_create(
            name='test loc',slug='test_loc')
    client,create = Client.objects.get_or_create(
            name='test client',slug='test_client', 
            )
    client.title_svg='test_show_title.svg' 
    client.category_key='test' 
    client.youtube_id='test' 
    client.archive_id='' 
    client.tweet_id='test' 
    client.tweet_prefix='test' 
    client.rax_id='testact' 
    client.bucket_id='example' 
    client.richard_id='test' 
            # title_svg = "pycon2013.svg",
            # host_user='veyepar_test', 
            # 00000001.png gets generated by mplayer, 
            # no easy way to make it a pretty name.
    client.credits="00000001.png"
    client.save()

    show,create = Show.objects.get_or_create( client=client,
                    name='test show',slug='test_show',)
    if create:
        show.locations.add(loc)

    ep = Episode.objects.create(
        show=show,
        location=loc,
        name=title,
        state=1,
        active = True,
        released=True,
        start = start_time,
        duration = "00:00:06",
        )

    # ep.name = "Test Episode" 
    # ep.name = u'TECHNICI\xc3\x84NS \xc3\x96F CH\xc4\xa8P\xc3\x9d THIS IS Y\xc3\x96\xc3\x9cR C\xc3\x84PT\xc3\x85IN SPE\xc3\x84KING Y\xc3\x96\xc3\x9cR \xc3\x98\xc3\x85PT\xc3\x85IN IS DEA\xcc\x8bD'

    ep.sequence = 1
    ep.description = desc
    ep.authors = "Test Author"
    ep.emails = "cfkarsten@gmail.com"
    ep.tags ="tag1,tag_2,tag 3"
    ep.save()

    return ep

def del_test_data():
    clients = Client.objects.filter(slug='test_client')
    if clients: clients[0].delete()

def tests(request):

    if request.method == 'POST': 
        if 'create' in request.POST:
            make_test_data()
        if 'delete' in request.POST:
            del_test_data()

    locations=Location.objects.filter(slug__contains="test")
    clients=Client.objects.filter(slug__contains="test")
    shows=Show.objects.filter(slug__contains="test")
    episodes=Episode.objects.filter(slug__contains="test")

    return render_to_response('tests.html',
       locals(),
       context_instance=RequestContext(request) )

def start_here(request):
    """
    landing page for someone who has never been here before 
    and wants to help.
    """

    show=get_object_or_404(Show,
            client__slug='eric',slug='write_docs_na_2016')
    episodes = Episode.objects.filter(show=show,
            location__active=True,
            state=1,
            locked__isnull=True,
            )
    # episodes = episodes.annotate(
    #                c=Count("cut_list")).filter(c__gte=1)
    episode = episodes[0]

    if request.method == 'POST':
        who = Who(request.POST)
        if who.is_valid(): 
            episode.locked_by = who.cleaned_data['locked_by']
            episode.locked = datetime.datetime.now()
            episode.save()
            return HttpResponseRedirect( 
                    reverse(approve_episode,
                     args=(episode.id, episode.slug, episode.edit_key,)))
    else:
        who = Who()

    return render_to_response('start_here.html',
        {'show':show, 
         'episode':episode,
         'who':who,},
       context_instance=RequestContext(request) )

def eps_csv(request,client_slug=None,show_slug=None):
    client=get_object_or_404(Client,slug=client_slug)
    show=get_object_or_404(Show,client=client,slug=show_slug)
    eps = Episode.objects.filter(show=show)

    rows = [(ep.id,
            ep.state,
            ep.name,
            ep.conf_key,
            ep.conf_url,
            ep.host_url) for ep in eps]

    # url = request.GET['url']
    response = HttpResponse(content_type="application/csv")
    response['Content-Disposition'] = \
            'inline; filename={}.csv'.format(show.slug)
    writer = csv.writer(response)
    for ep in eps:
        row = [ep.id,
            ep.state,
            ep.slug.encode('utf-8'),
            # ep.name,
            ep.conf_key,
            ep.conf_url,
            ep.host_url,
            ]
        writer.writerow(row)

    return response

def eps_xfer(request,client_slug=None,show_slug=None):
    """
    Returns all the episodes for a show as json.
    Used to synk public url's with the main conference site.
    """

    client=get_object_or_404(Client,slug=client_slug)
    show=get_object_or_404(Show,client=client,slug=show_slug)
    eps = Episode.objects.filter(show=show)

    if "id" in request.GET:
        eps = eps.filter( id=request.GET['id'] )

    fields=['id',
            'state',
            'location', 
            'get_location_name', 
            'sequence',
            'name', 'slug', 'authors', 'description',
            'start', 'duration', 
            'released', 'license', 'tags',
            'conf_key', 'conf_url',
            'host_url', 'public_url', 'rax_mp4_url', 'archive_mp4_url',
            'twitter_url', 
            'comment',
        ]
    if request.user.is_authenticated():
        fields.extend(['emails', 'edit_key','conf_meta'])

    response = HttpResponse(content_type="application/json")
    serializers.serialize("json", eps, 
            fields=fields, use_natural_keys=True,
            stream=response)

    return response


def eps_lanynard(request,client_slug=None,show_slug=None):
    """
    json feed to send to Lanyard, cuz wacky backward.
    https://docs.google.com/document/d/1aT_mIJ7Q-eawamGs_9HrBZL_Lfa0dBohXhc1SpfYSj0/pub?embedded=true
    """

    client=get_object_or_404(Client,slug=client_slug)
    show=get_object_or_404(Show,client=client,slug=show_slug)
    eps = Episode.objects.filter(show=show)

    #venue id - SEP
    vid=request.GET.get('vid','')

    field_map = (
            ('conf_url','crowdsource_ref'),
            ('name','title'),
            ('description','abstract'),
            # ('','start_time'),
            # ('','end_time'),
            # ('location','space_name'),
            # ('','venue'),
            # ('','speakers'),
            )
            

    sessions = []
    for ep in eps:
        session = {}
        for s,d in field_map:
            session[d]=getattr(ep,s)
        session['start_time'] = ep.start.strftime('%Y-%m-%d %H:%M:%S')
        session['end_time'] = ep.end.strftime('%Y-%m-%d %H:%M:%S')
        session['venue'] = vid
        session['space_map'] = ep.location.name

        speakers=[]
        if ep.authors:
            for i,name in enumerate(ep.authors.split(',')):
                speaker={'crowdsource_ref': "{0}/speakers/{1}".format(
                            session['crowdsource_ref'],i),
                         'name':name,
                         'role':'',
                         }
                speakers.append(speaker)
        session['speakers']=speakers

        sessions.append(session)
        

    response = HttpResponse(content_type="application/json")
    json.dump(sessions,response)

    return response

def main(request):
    return render_to_response('main.html',
        context_instance=RequestContext(request) )

def meet_ann(request,show_id):
    show=get_object_or_404(Show,id=show_id)
    client=show.client
    episodes=Episode.objects.filter(show=show).order_by('start')
    location=episodes[0].location
    t = loader.get_template('meeting_announcement.html')
    c = Context(
        {'client':client,'show':show,
          'ANN_STATES': ANN_STATES,
          'location':location,
          'episodes':episodes,
    })
    r = t.render(c)
    if request:
        return HttpResponse("<pre>%s</pre>" % r)
    else:
        # called from emailer
        r=r.split('\n')
        subject = r[1]
        body = '\n'.join(r[3:])
        return subject,body

def emailer(show_id, ):
    show=get_object_or_404(Show,id=show_id)

    # show.announcement_state drives which of the following 3 get used:
    # 1. preview is for proofing the whole thing
    # 2. review is for the presenters to review their part
    # 3. approved means it is ready for distribution

    admin_emails = ['carl@personnelware.com', ]

    def author_emails(show):
        # return a list of email addresses for the show
        # pems = [ '"Brian Moloney" <brian@imagescape.com>' ]
        pems = [ 'brianhray@gmail.com' ]
        episodes=Episode.objects.filter(show=show)
        for ep in episodes:
            if ep.emails:
                emails = ep.emails.split(',')
                pems.extend(emails)
        return pems

# need to join the #ed lists
    announce_lists = [
 # '"ChiPy" <chicago@python.org>', 
 '"ChiPy Announce" <ChiPy-announce@python.org>',
 '"PS1" <pumping-station-one-public@googlegroups.com>',
 '"ACM Chicago" <mtemkin@speakeasy.net>',
 # '"ACM Chicago" <chicago-chapter-acm@googlegroups.com>',
 # '"Chicago Linux Discuss" <chicagolinux-discuss@googlegroups.com>',
 # '"UFO Chicago" <ufo@ufo.chicago.il.us>', 
 '<chicagotechcal@gmail.com>',
 'clclinuxclub@gmail.com',
 ]
    tos = { 1: admin_emails,
             2: author_emails(show),
             3: announce_lists}[show.announcement_state]

    subject,body=meet_ann(None,show_id)
    print(subject)
    print(body)
    print(tos)
    
    # connect to the smtp server
    connection = get_connection()
    sender = 'Carl Karsten <cfkarsten@gmail.com>'
    headers = {
        # 'Reply-To': "ChiPy <chicago@python.org>"
        # 'From': sender,
        }
    for to in tos:
        email = EmailMessage(subject, body, sender, [to], headers=headers ) 
        ret = connection.send_messages([email])
        print(to, ret)

    return

def show_urls(request,show_id):
    show=get_object_or_404(Show,id=show_id)
    client=show.client
    episodes=Episode.objects.filter(show=show).order_by('start')

    return render_to_response("show_urls.html",
        {
          'client':client,
            'show':show, 
            'episodes':episodes,
            },
        context_instance=RequestContext(request) )
 
def schedule(request, show_id, show_slug, template_name):

    if "blank" in request.GET:
        blank_me = True
    else:
        blank_me = False

    show=get_object_or_404(Show,id=show_id)
    locations=show.locations.filter(active=True).order_by('sequence')
    episodes=Episode.objects.filter(show=show)

    # order_by to override Meta: ordering = ["sequence"]
    # which will get included in the field list and break the .distinct().
    times=episodes.order_by('start').values('start','end').distinct()
    times=episodes.order_by('start').values('start').distinct()

    dates = list(set(t['start'].date() for t in times))
    dates.sort()

    # pprint([s for s in starts if s.date()==dates[1]])
        
    # [[d1,[[t1,[e1,e2,e3]],
    #       [t2,[e4,e5,e6]]],
    #  [d2,[[t3,[e7,e8,e9]]]]]]

    days=[]
    for d in dates:
        rows=[]
        for t in times:
            if t['start'].date() == d:
                slots=[]
                for loc in locations: 
                    i=None
                    for ep in episodes:
                        if ep.location == loc and  ep.start == t['start'] : 
                            i = ep
                    slots.append(i)
                rows.append([t,slots])
        days.append([d,rows])


    return render_to_response(template_name,
        {'show':show, 
        'locations':locations,
        'blank_me':True,
        'days':days},
        context_instance=RequestContext(request) )
       
def episode_pdfs(request, show_id, episode_id=None, rfxml='test.rfxml'):
    """
    Generates a pdf 
    for all episodes in a show or just one episode
    layout defined by rfxml
    """
    try:
        from dabo.dReportWriter import dReportWriter
    except ImportError:
        raise Http404("Dabo is not installed")
    
    show=get_object_or_404(Show,id=show_id)
    client = show.client

    if episode_id:
        episodes=Episode.objects.filter(id=episode_id)
    else:
        episodes=Episode.objects.filter(
                show=show, location__active=True
                ).order_by('location__sequence','start')

    if "day" in request.GET:
        episodes = episodes.filter( start__day=request.GET['day'] )
    if "date" in request.GET:
        episodes = episodes.filter( start__startswith=request.GET['date'] )
    if "state" in request.GET:
        episodes = episodes.filter( state=request.GET['state'] )

    if "room" in request.GET:
        episodes = episodes.filter( location__slug=request.GET['room'] )

    base  = os.path.dirname(__file__)
    rfxmlfile  = os.path.join(base,'templates', rfxml+".rfxml")
     
    # buffer to create pdf in
    buf = BytesIO()

    # nonstandard font.  (not sure what standard is.)
    # fontfile = get_templete_abspath('badges/fonts/FreeSans.ttf')
    # pdfmetrics.registerFont(TTFont("FreeSans", fontfile))
    
    ds=[]
    for ep in episodes:
        if ep.location:
            location_name=ep.location.name
            location_dir=ep.location.dirname
        else:
            location_name='None'
        ds.append({'episode_id':ep.id,
          'episode_conf_key':ep.conf_key,
          'episode_primary':ep.conf_key,
          'episode_name':ep.name,
          'episode_authors':ep.authors,
          'episode_emails':
            ep.emails if request.user.is_authenticated() else '',
          'episode_start':ep.start,
          'episode_duration':ep.duration,
          'episode_end':ep.end,
          'episode_released':ep.released,
          'location_name':location_name,
          'location_dir':location_dir,
          'client_name':client.name,
          'show_name':show.name,
          })
        
    # generate the pdf in the buffer, using the layout and data
    rw = dReportWriter(OutputFile=buf, ReportFormFile=rfxmlfile, Cursor=ds)
    rw.write()

    # get the pdf out of the buffer
    pdf = buf.getvalue()
    buf.close()

    response = HttpResponse(content_type='application/pdf')
    e_id = episode_id if episode_id else 'all'
    filename = '_'.join( [client.slug, show.slug, e_id, rfxml] )
    response['Content-Disposition'] = \
      'filename=%s.pdf' % ( filename )
    response.write(pdf)
    return response

def mk_play_list(request):
    url = request.GET['url']
    response = HttpResponse(content_type='audio/mpegurl')
    response['Content-Disposition'] = 'inline; filename=playlist.m3u'
    writer = csv.writer(response)
    writer.writerow([url])
    return response

def raw_play_list(request, episode_id):
    episode=get_object_or_404(Episode,id=episode_id)
    show=episode.show
    client=show.client
    
    # cuts = Cut_List.objects.filter(episode=episode).order_by('raw_file__start')
    cuts = Cut_List.objects.filter(episode=episode).order_by('sequence', 'raw_file__start')
    if request.GET.get('apply') == 'yes':
        # if we only want the 'applied' files
        cuts = cuts.filter(apply=True)

    response = HttpResponse(content_type='audio/mpegurl')
    # response['Content-Disposition'] = 'attachment; filename=playlist.m3u'
    response['Content-Disposition'] = 'inline; filename=playlist.m3u'

    writer = csv.writer(response)
    # if request.GET.get('META.HTTP_HOST') == "localhost:8080":
    #    head="file://~Videos/xxx"
    # else:
    head=settings.MEDIA_URL
    for cut in cuts:

        if "ext" in request.GET:
            # this assumes the ext being removed is "dv" (2 chars)
            pathname = os.path.join(head,client.slug,show.slug,'dv',cut.raw_file.location.slug, cut.raw_file.filename )[:-2]+request.GET['ext'] 
        else:
            pathname = os.path.join(head,client.slug,show.slug,'dv',cut.raw_file.location.slug, cut.raw_file.filename )

        writer.writerow([pathname])

    return response

def public_play_list(request):
    # experiment to construct a playlist that is based on query params
    
    # build up the filter:
    episodes = Episode.objects

    if "id" in request.GET:
        episodes = episodes.filter( id=request.GET['id'] )

    if "client" in request.GET:
        episodes = episodes.filter(
                show__client__slug=request.GET['client'] )

    if "show" in request.GET:
        episodes = episodes.filter( show__slug=request.GET['show'] )

    if "location" in request.GET:
        episodes = episodes.filter( location__slug=request.GET['location'] )

    if "date" in request.GET:
        episodes = episodes.filter( start__startswith=request.GET['date'] )

    if "state" in request.GET:
        episodes = episodes.filter( state=request.GET['state'] )


    response = HttpResponse(content_type='audio/mpegurl')
    # response['Content-Disposition'] = 'attachment; filename=playlist.m3u'
    response['Content-Disposition'] = 'inline; filename=playlist.m3u'

    # create the base of the URLs
    head=settings.MEDIA_URL
    # show_url = os.path.join(head,client.slug,show.slug)

    ext = "mp4"

    writer = csv.writer(response)
    for ep in episodes:
        show_url = os.path.join("/home/carl/Videos/veyepar", 
                ep.show.client.slug, ep.show.slug)
        writer.writerow([os.path.join(
            show_url, ext, "{}.{}".format(ep.slug,ext))])
        if ep.public_url:
            writer.writerow([ep.public_url])

    return response


def enc_play_list(request,episode_id):
    episode=get_object_or_404(Episode,id=episode_id)
    show =episode.show
    client=show.client

    response = HttpResponse(content_type='audio/mpegurl')
    # response['Content-Disposition'] = 'attachment; filename=playlist.m3u'
    response['Content-Disposition'] = 'inline; filename=playlist.m3u'

    writer = csv.writer(response)
    # exts = [ 'ogv','flv', 'mp4', 'm4v', 'ogg', 'mp3' ]:
    exts = [ 'webm', ]
    for ext in exts:
        
      foot_pathname = os.path.join(client.slug,show.slug, ext, '%s.%s' % (episode.slug, ext))
      print(os.path.join(os.path.expanduser('~/Videos/veyepar'), foot_pathname))

      if os.path.exists( 
          os.path.join(os.path.expanduser('~/Videos/veyepar'), foot_pathname)):
        
        if settings.MEDIA_URL.startswith('file:/'):
            head=settings.MEDIA_URL
        else:
            # probably no local file access
            # head='http://'+request.META['HTTP_HOST']+settings.MEDIA_URL
            head=settings.MEDIA_URL
            # so review the smaller iPhone file
        item = '/'.join([head, foot_pathname ] )
        writer.writerow([item])


    return response


def play_list(request,show_id,location_slug=None):
    show=get_object_or_404(Show,id=show_id)
    client=show.client
    episodes=Episode.objects.filter(show=show,state=3).order_by('sequence')
    if location_slug:
        episodes = episodes.filter(location__slug=location_slug)

    response = HttpResponse(content_type='audio/mpegurl')
    response['Content-Disposition'] = 'attachment; filename=playlist.m3u'

    writer = csv.writer(response)
    for ep in episodes:
        # pathname = os.path.join( settings.MEDIA_URL,client.slug,show.slug,ext,
        if settings.MEDIA_URL.startswith('file:/'):
            head=settings.MEDIA_URL
            ext='mp4'
        elif settings.MEDIA_URL.startswith('http:/'):
            head=settings.MEDIA_URL
            ext='mp4'
        else:
            # probably no local file access
            head='http://'+request.META['HTTP_HOST']+settings.MEDIA_URL
            # so review the smaller iPhone file
            ext='m4v'
        item = '/'.join([head, client.slug,show.slug,ext, '%s.%s' % (ep.slug, ext)] )
        writer.writerow([item])

    return response

def meet_ical(request,location_id):
    location=get_object_or_404(Location,id=location_id)
    show=location.show
    client=show.client
    episodes=Episode.objects.filter(show=show).order_by('sequence')
    location=episodes[0].location
    return render_to_response('meeting_announcement.html',
        {'client':client,'show':show,
          'location':location,
          'episodes':episodes,
        },
        context_instance=RequestContext(request) )

def former(request, Model, parents, inits={}):

    class xForm(ModelForm):
        exclude=[]
        class Meta:
            model=Model

    if True or request.user.is_authenticated():
        if request.method == 'POST':
            form=xForm(request.POST)
            if form.is_valid():
                form.save()
            else:
                # print form.errors
                pass
        else:
            # add parents to inits
            inits.update(parents)
            form=xForm(initial=inits)
    else:
        form=None

    objects=Model.objects.filter(**parents).order_by('sequence')
    return form,objects

def clients(request):
    # list of clients and a blank to enter a new one

    class Client_Form(ModelForm):
        class Meta:
            model=Client
            fields=('name','slug','tags','description')


    if request.user.is_authenticated():
        if request.method == 'POST':
            # client=Client(sequence=1)
            # form=Client_Form(request.POST,instance=client)
            form=Client_Form(request.POST)
            if form.is_valid():
                form.save()
                return HttpResponseRedirect(
                        reverse(client, args=(form.cleaned_data['slug'],)))
            else:
                pass
                # print form.errors
        else:
            form=Client_Form(initial={'sequence':1})
    else:
        form=None

    clients=Client.objects.annotate( 
            max_date=Max('show__episode__start')) \
            .filter(active=True) \
            .order_by('-max_date')

    return render_to_response('clients.html',
        {'clients':clients,
        'client_form':form},
       context_instance=RequestContext(request) )


def client(request,client_slug=None):
    # the selected client and
    # list of client's shows and a blank to enter a new show

    client=get_object_or_404(Client,slug=client_slug)

    shows=Show.objects.filter(client=client)\
            .annotate( max_date=Max('episode__start'))\
            .order_by('-max_date')

    class Show_Form(ModelForm):
        class Meta:
            model=Show
            fields=('name','slug','locations','tags','description')

    if request.user.is_authenticated():
        if request.method == 'POST':
            show=Show(client=client,sequence=1,)
            form=Show_Form(request.POST,instance=show)
            if form.is_valid():
                form.save()
                return HttpResponseRedirect(reverse(episodes, args=(client_slug, form.cleaned_data['slug'])))
            else:
                pass
                # print form.errors
        else:


            # locations=Location.objects.filter(active=True).order_by('sequence')
            # I am not sure what a good default is for locations.
            locations=[]

            initial={'client':client.id, 'sequence':1}
            if shows:
                last_show = shows[0]
                initial['name']=last_show.name
                initial['locations']= \
                        last_show.locations.filter(active=True)
                initial['sequence']=last_show.sequence+1

            form=Show_Form( initial=initial )
    else:
        form=None

    return render_to_response('client.html',
        {'client':client,
        'show_form':form,
        'shows':shows},
       context_instance=RequestContext(request) )

def locations(request):
    location_form, locations = former(
        request, Location, {},{'sequence':1})
    return render_to_response('locations.html',
        {
          'locations':locations,
          'location_form':location_form,
        },
    context_instance=RequestContext(request) )
 
def show_anomalies(request, show_id, ):
    show=get_object_or_404(Show,id=show_id)
    client=show.client

    episodes=Episode.objects.filter(show=show,)
    if "active" in request.GET:
        episodes = episodes.filter(location__active=True)

    max_title_len = max( len(ep.name) for ep in episodes )
    max_authors_len = max( len(ep.authors) for ep in episodes if ep.authors is not None)

    max_name_ep = None
    max_authors_ep = None
    max_name_len = 0
    max_authors_len = 0
    for ep in episodes:
        if len(ep.name) > max_name_len:
            max_name_len = len(ep.name)
            max_name_ep = ep
        if ep.authors is not None and \
                len(ep.authors) > max_authors_len:
            max_authors_len = len(ep.authors)
            max_authors_ep = ep

    dupes = Episode.objects.values('slug').annotate(Count('id')).order_by().filter(id__count__gt=1, show=show)
    dup_eps = Episode.objects.filter(slug__in=[item['slug'] for item in dupes], show=show)

    # if someone starts a video file when the talk starts, that is clean.
    # if they miss the start by so much that some needs to be removed 
    #   (thus start=2 min into the start of the file) that is dirty 
    episodes=Episode.objects.filter(show=show,state__gt=1)
    clean,dirty = 0,0
    for ep in episodes:
        found=False
        cuts = Cut_List.objects.filter(episode=ep)
        for cut in cuts:
            found = found or cut.start or cut.end
        if found: dirty += 1
        else: clean += 1


    return render_to_response('show_anomalies.html',
        {
          'client':client,
          'show':show,
          'locations':locations,
          'dup_eps':dup_eps,
          'clean':clean, 'dirty':dirty,
          'max_name_ep':max_name_ep,
          'max_authors_ep':max_authors_ep,
          'now':datetime.datetime.now(),
        },
    context_instance=RequestContext(request) )

def show_pipeline(request, show_id ):

    show=get_object_or_404(Show,id=show_id)
    client=show.client
    # episodes=Episode.objects.filter(show=show,location__active=True)
    # ep_states = Episode.objects.values('state').annotate(Count('state')).order_by().filter(show=show,location__active=True).order_by('state')

    states = State.objects.all()
    statesl = [] 
    for s in states:

        ep_states = Episode.objects.values('state').annotate(Count('state')).order_by().filter(show=show,location__active=True, state=s.sequence)

        if ep_states:
            count=ep_states[0]['state__count']
        else:
            count=0

        stated = {
                'sequence':s.sequence,
                'slug':s.slug,
                'description':s.description,
                'count':count }

        statesl.append(stated)

    return render_to_response('show_pipeline.html',
        {
          'client':client,
          'show':show,
          'statesl':statesl,
        },
    context_instance=RequestContext(request) )


def show_stats(request, show_id, ):
    """
    Show Status - varous summaries of rooms, days and the whole thing
    """

    show=get_object_or_404(Show,id=show_id)
    client=show.client
    episodes=Episode.objects.filter(show=show,location__active=True)
    lockeds=Episode.objects.filter(show=show, locked__isnull=False).order_by('locked')
    raw_files=Raw_File.objects.filter(show=show,location__active=True)
    locations=show.locations.filter(active=True).order_by('sequence')
    
    # needs better organazation.  refactor please.
    empty_stat = {
            'ep':{
               'times': [False] * 24,
               },
               'count':0,'minutes':0, 
               'start':None, 'end':None, 'states':[0]*len(STATES),
               'loc':None, 'date':None,
               'raw':{
                   'start':None, 
                   'end':None,
                   'times': [False] * 24,
                   },
               'files':0, 'bytes':0, 
               }
 
    # get the range of dates used by this show
    # which is a combonation of scheduled dates and dates of videos
    # there really shouldn't be video files outside the range 
    # so those should be cleaned up.
    dates=[] 

    for rf in raw_files:
        if rf.start is not None:
            dt = rf.start.date()
            if dt not in dates: dates.append(dt)

    for ep in episodes:
        dt = ep.start.date()
        if dt not in dates: dates.append(dt)

    dates.sort()
    
    # show totals:
    show_stat = deepcopy(empty_stat)

    # make 3 dicts of empty stats
    # 1. for each room-day (date,loc)
    stats={} 
    for loc in locations: 
        for dt in dates: 
            d = deepcopy(empty_stat)
            d['loc'] = loc
            d['date'] = dt
            stats[(dt,loc.id)] = d

    # 2. for locations:
    d={}
    for loc in locations:
        d[loc.id] = deepcopy(empty_stat)
        d[loc.id]['loc'] = loc
    locations=d

    # 3. for dates:
    d={}
    for dt in dates:
        d[dt] = deepcopy(empty_stat)
    dates=d

    # gather episode stats
    # func to update one:


    def set_times(times,s,e):
        # times: list of bools
        # s,e: start/end datetimes
        sh = s.hour
        eh = (e + datetime.timedelta(minutes=59)).hour # bump up to next h
        times[sh:eh] = [True]*(eh-sh)


    def add_ep_to_stat(ep,stat):

        set_times( stat['ep']['times'], ep.start, ep.end)

        stat['count']+=1        
        duration=ep.end-ep.start        
        stat['minutes']+=duration.seconds/60        
        stat['start']=ep.start if stat['start'] is None else min(stat['start'],ep.start)
        stat['end']=ep.end if stat['end'] is None else max(stat['end'],ep.end)
        if 0<= ep.state <= len(STATES):
            stat['states'][ep.state]+=1        
        else:
            stat['states'][0]+=1        

        return

    for ep in episodes:
        dt = ep.start.date()
        loc = ep.location.id

        # update grand total:
        add_ep_to_stat(ep,show_stat)
        
        # update total for date:
        add_ep_to_stat(ep,dates[dt])
        
        # update total for location:
        add_ep_to_stat(ep,locations[loc])
        
        # update room-loc
        add_ep_to_stat(ep,stats[(dt,loc)])


    def add_rf_to_stat(rf,stat):
        set_times( stat['raw']['times'], rf.start, rf.end)
        stat['files'] += 1
        stat['bytes'] += rf.filesize

        stat['raw']['start']=rf.start if stat['raw']['start'] is None else min(stat['raw']['start'],rf.start)
        stat['raw']['end']=rf.end if stat['raw']['end'] is None else max(stat['raw']['end'],rf.end)
        return

    # gather raw_file stats
    for rf in raw_files:
        if rf.start is not None:
            dt = rf.start.date()
            loc = rf.location.id

            add_rf_to_stat(rf,show_stat)
            add_rf_to_stat(rf,dates[dt])
            add_rf_to_stat(rf,locations[loc])
            add_rf_to_stat(rf,stats[(dt, loc)])

    # make lists out of the dics cuz I can't figur out how to get at the dict
 
    # and do some more calcs
    def calc_stat(stat):

        stat['ep']['times_display'] = ''.join( 
                'x' if t else 'o' for t in stat['ep']['times'])
        stat['raw']['times_display'] = ''.join( 
                'x' if t else 'o' for t in stat['raw']['times'])
        stat['times_display'] = ''.join( {
            (False, False):' ',
            (False, True) :'~',
            (True, False) :'!',
            (True, True)  :'.'}[er] for er in zip( 
                stat['ep']['times'], stat['raw']['times']) ).strip()

        stat['hours']=int( stat['minutes']/60.0 + .9)
 
        stat['talk_gig']=int(stat['minutes']*13/60)
        stat['gig']=stat['bytes']/(1024**3)

        stat['variance'] = stat['talk_gig'] - stat['gig']   

        # alarm is % of expected gig, 0=perfect, 20 or more = wtf?
        stat['alarm']= int(
               stat['variance'] / (stat['minutes']/60.0*13 + 1) * 100 )
        if stat['alarm'] > 0: # red
            stat['alarm_color'] = "%02x%02x%02x" % ( 
                    255, 255-stat['alarm'], 255-stat['alarm'] )
        else: # yellow
            # 250, 255, 189
            stat['alarm_color'] = "%02x%02x%02x" % ( 
                    255, 255, 255 + stat['alarm'] )
        return stat

    show_stat = calc_stat(show_stat)
    l = []
    for dt in dates:
        d = dates[dt]
        d['date'] = dt
        d = calc_stat(d)
        l.append(d)
    l.sort(key=operator.itemgetter('date'))
    dates=l
    # pprint(dates)
 
    l = []
    for loc in locations:
        d = locations[loc]
        d['seq'] = d['loc'].sequence
        d = calc_stat(d)
        l.append(d)
    l.sort(key=operator.itemgetter('seq'))
    locations=l
    # pprint(locations)

    rows=[]
    for dt in dates: 
        dt=dt['date']
        row=[]
        for loc in locations: 
            stat = calc_stat(stats[(dt,loc['loc'].id)])
            row.append((stat,loc))
        rows.append(row)
    
    states = list(zip( show_stat['states'], STATES))
    rows = list(zip(dates,rows))

    return render_to_response('show_stats.html',
        {
          'client':client,
          'show':show,
          'locations':locations,
          'show_stat':show_stat,
          'rows':rows,
          'states':states,
          'locked':lockeds,
        },
    context_instance=RequestContext(request) )


def processes(request, show_id, ):
    """
    What is locked, so should be being worked on.
    """

    show=get_object_or_404(Show,id=show_id)
    client=show.client
    lockeds=Episode.objects.filter(show=show, locked__isnull=False).order_by('locked')

    return render_to_response('processes.html',
        {
          'client':client,
          'show':show,
          'locked':lockeds,
        },
    context_instance=RequestContext(request) )

def raw_file(request, raw_file_id):

    rf=Raw_File.objects.get(id=raw_file_id)
    eps = scheduled_episodes(rf)
    # Raw_File.objects.filter(cut_list__episode=episode)
    # eps = Episode.objects.filter(cut_list__raw_file=rf)

    return render_to_response('raw_file.html',
        {
          'raw_file':rf,
          'eps':eps,
        },
        context_instance=RequestContext(request) )

def rf_set(request, location_slug):
    # Show files collected for a given location and date
    # aka a set, corisponds to a set of recording sheets.

    location = Location.objects.get(slug=location_slug)

    rfs=Raw_File.objects.filter( 
            location=location).order_by('start')
 
    if "start_date" in request.GET:
        start_date=request.GET['start_date']
        rfs=rfs.filter(start__startswith=start_date)
 
    trash = None
    if "trash" in request.GET:
        trash=request.GET['trash'].lower()=="y"
        rfs=rfs.filter(trash=trash)
 
    rf_cls=[]
    for rf in rfs:
        # eps = scheduled_episodes(rf)
        cls = rf.cut_list_set.all()
        rf_cls.append([rf,cls])
    
    return render_to_response('raw_set.html',
        {
          'trash':trash,
          'location':location,
          'rf_cls':rf_cls,
        },
        context_instance=RequestContext(request) )


def raw_file_audio(request):
    """
    visulation of audio for a room-day of talks
    template will group files one hour per row
    """

    # there better be a show_id
    show = Show.objects.get(id=request.GET['show_id'])
    locations=Location.objects.filter(show=show)

    if "active" in request.GET:
        locations=locations.filter(active=True)
    if "location_slug" in request.GET:
        locations=locations.filter(slug=request.GET['location_slug'])

    rfs=Raw_File.objects.filter(show=show,
            trash=False,
            location__in=locations,
            ).order_by('start')

    if "start_date" in request.GET:
        start_date=request.GET['start_date']
        rfs=rfs.filter(start__startswith=start_date)
 
    # pull out the hour so the template can group on it
    rf_audios=[]
    for rf in rfs:
        rf_audio={'rf':rf,
                'hour':rf.start.hour,
                }
        rf_audios.append(rf_audio)

    # find the previous and next room-day
    # for now assume there are locations
    location = locations[0]

    # get previous location
    locations=Location.objects.filter( 
            show=show,
            sequence__lt=location.sequence,
            ).order_by('-sequence',)[:1]

    if locations:
        prev_location = locations[0]
    else:
        prev_location = None

    # get next location
    locations=Location.objects.filter( 
            show=show,
            sequence__gt=location.sequence,
            ).order_by('sequence',)[:1]

    if locations:
        next_location = locations[0]
    else:
        next_location = None
        

    return render_to_response('raw_file_audio.html',
        {
          'show':show,
    #      'start_date':start_date,
          'prev_location':prev_location,
          'location':location,
          'next_location':next_location,
          'rf_audios':rf_audios,
        },
        context_instance=RequestContext(request) )


def final_file_audio(request):

    show = Show.objects.get(id=request.GET['show_id'])
    client=show.client
    episodes=Episode.objects.filter(show=show,).order_by('start')

    state = request.GET.get('state')
    if state is not None:
        episodes=episodes.filter(state=state)

    epid = request.GET.get('epid')
    if epid is not None:
        episodes=episodes.filter(id=epid)

    return render_to_response('final_file_audio.html',
        {
          'client':client,
          'show':show,
          'episodes':episodes,
        },
        context_instance=RequestContext(request) )


def orphan_img(request, show_id, ):

    show=get_object_or_404(Show,id=show_id)
    client=show.client

    # dupes = Episode.objects.values('slug').annotate(Count('id')).order_by().filter(id__count__gt=1, show=show)

    if request.user.is_authenticated():
        AddImageToEpFormSet = formset_factory(AddImageToEp, extra=0)
        if request.method == 'POST':
            formset = AddImageToEpFormSet(request.POST)
            for form in formset:
                if form.is_valid():
                    episode_id = form.cleaned_data['episode_id']
                    if episode_id is not None:
                        img = get_object_or_404(Image_File, 
                                id=form.cleaned_data['image_id'])
                        episode = get_object_or_404(Episode,id=episode_id)
                        img.episodes.add(episode)
                    # I wonder how this should get handled
                    # form.errors

    orphan_images = Image_File.objects.annotate(
            Count("episodes")).filter(show=show,episodes__count=0)

    init = [{'image_id':img.id,} for img in orphan_images]
    formset = AddImageToEpFormSet(initial=init)

    return render_to_response('imgs.html',
            {
          'client':client,
          'show':show,
          'imgsfs':list(zip(orphan_images,formset.forms)),
          'iefs':formset,
          },
        context_instance=RequestContext(request) )


def title_slides(request, show_id, ):

    show=get_object_or_404(Show,id=show_id)
    client=show.client

    # episodes=Episode.objects.filter(show=show, 
    #    location__active=True)
    # .exclude(emails='')

    kwargs = {
            "show": show,
            "location__active": True,
            # "emails": request.GET['emails'],
            # "show__client__slug": request.GET['client'],
            # "show__slug": request.GET['show'],
            # "": request.GET[''],
            }

    if "state" in request.GET:
        kwargs["state"] = request.GET['state']

    # if "active" in request.GET:
    #    kwargs["location__active"] = request.GET['active'].lower() == "true"

    episodes=Episode.objects.filter(**kwargs).order_by(
            'location',
            'start', 
            )

    return render_to_response('title_slides.html',
            {
          'client':client,
          'show':show,
          'episodes':episodes,
          },
        context_instance=RequestContext(request) )

def episodes_script(request, script=None):

    kwargs = {
            "show__client__slug": request.GET['client'],
            # "show__slug": request.GET['show'],
            # "state": request.GET['state'],
            # "": request.GET[''],
            }

    # print kwargs

    episodes=Episode.objects.filter(**kwargs).order_by('start')

    # episodes=Episode.objects.filter(show__slug="fosdem_2014", state='5').order_by('start')
    print(len(episodes))

    response = render_to_response(
            'episodes_script.txt',
            { 'episodes':episodes,
                'script':script,
            },
            context_instance=RequestContext(request),
            content_type="text/plain",
            )

    response['Content-Disposition'] = 'filename={0}.sh'.format( script )

    return response 


def episode_assets(request, episode_id):
    """
    returns a list of URLs of the assets (in preview form)
    and the .mlt and .sh
    """

    assets=[]

    episode=get_object_or_404(Episode,id=episode_id)
    slug = episode.slug
    show=episode.show
    client=show.client

    # the base of the URLs
    head=settings.MEDIA_URL
    show_url = os.path.join(head,client.slug,show.slug)

    assets.append( "wget -N --force-directories -i http://"
            + request.META['HTTP_HOST'] + request.get_full_path() )

    assets.append( "{}/mlt/{}.mlt".format(show_url,slug) )
    # assets.append( "{}/tmp/{}.sh".format(show_url,slug) )
    assets.append( "{}/titles/{}.png".format(show_url,slug) )
    assets.append( "{}/titles/{}.svg".format(show_url,slug) )
    assets.append( "{}/assets/{}".format(show_url, client.credits) )

    # add the raw files
    cuts = Cut_List.objects.filter(episode=episode).order_by('sequence', 'raw_file__start')
    if request.GET.get('apply') == 'yes':
        cuts = cuts.filter(apply=True)
    
    rfs = Raw_File.objects.filter(cut_list__in=cuts).distinct()

    for rf in rfs:
        assets.append( "{}/dv/{}/{}.webm".format(show_url,
            rf.location.slug, rf.filename ) )

    # make symlinks from epected filename to smaller webm 
    show_path = urllib.parse.urlparse(show_url)
    first_dir = '"{}{}/dv/{}/{}"'.format( show_path.netloc, show_path.path,
            rf.location.slug, 
            os.path.split(rf.filename)[0])

    assets.append("cd " + first_dir)
    for rf in rfs:
        filename = os.path.split(rf.filename)[1]
        assets.append( "ln -s {0}.webm {0}".format(filename) )

    response = HttpResponse('\n'.join(assets), content_type="text/plain")
    response['Content-Disposition'] = \
            'inline; filename={}.urls'.format(slug)

    return response


    
def episode_list(request, state=None):

    states = State.objects.all()

    episodes=Episode.objects.filter(state=state, show__active=True).order_by('start')
    if "show" in request.GET:
        episodes = episodes.filter( show__slug=request.GET['show'] )

    return render_to_response('episode_list.html',
            { 'episodes':episodes,
                'states':states,
        },
        context_instance=RequestContext(request) )


def episodes(request, client_slug=None, show_slug=None, location_slug=None,
              start_day=None, state=None):

    client=get_object_or_404(Client,slug=client_slug)
    show=get_object_or_404(Show,client=client,slug=show_slug)

    location_slug = location_slug if location_slug \
            else request.GET.get('location_slug')

    start_date = request.GET.get('date')

    cuts = request.GET.get('cuts')
    emails = request.GET.get('emails')
    comment = request.GET.get('comment')
    released = request.GET.get('released')
    images = request.GET.get('images')
    log_has = request.GET.get('log_has')

    order_by = request.GET.get('order_by')

    if "state" in request.GET:
        state = request.GET.get('state')

    locations=show.locations.filter(active=True).order_by('sequence')
    episodes=Episode.objects.filter(show=show)

    admin_params="show__id__exact=%s" % show.id

    if location_slug:
        # location here is for default location for new episodes
        location=get_object_or_404(Location,slug=location_slug)
        episodes=episodes.filter(location=location)
        admin_params += "&location__id__exact=%s" % location.id
    else:
        episodes=episodes.filter(location__active=True)

    if start_date:
        episodes = episodes.filter(start__startswith=start_date)
        admin_params +="&start__date=%s" % start_date
    if start_day:
        episodes = episodes.filter(start__day=start_day)
        admin_params +="&start__day=%s" % start_day
    if state:
        episodes = episodes.filter(state=state)
        admin_params += "&state__exact=%s" % state
      #   if state=='0':
      #  episodes = episodes.filter(state__isnull=True)

    if cuts:
        if cuts=="0":
            # only show episodes with no raw files found
            episodes = episodes.filter(cut_list__isnull=True)
        else:
            # that have cuts cuts or more cuts
            episodes = episodes.annotate(
                    c=Count("cut_list")).filter(c__gte=cuts)
            
    if emails:
        episodes = episodes.exclude(emails="")

    if comment:
        episodes = episodes.exclude(comment="")

    if released:
        episodes = episodes.filter(released=True)


    if images:
        if images=="0":
            # only show episodes with no raw files found
            episodes = episodes.filter(image_file__isnull=True)
        else:
            # episodes = episodes.filter(image_file__isnull=False)
            episodes = episodes.annotate(
                    c=Count("image_file")).filter(c__gte=images)

    if log_has:
        # track down eisode's that were encoded on box X
        episodes = episodes.filter(log__result=log_has).distinct()

    if order_by:
        if order_by == "location,start":
            episodes = episodes.order_by('location__sequence','start')
    else: 
        episodes = episodes.order_by('start')

    if request.user.is_authenticated():
        if request.method == 'POST':
            form=Episode_Form_Preshow(request.POST)
            if form.is_valid():
                episode = form.save()
                # setup next form
                # use saved Episode as a base for defaults
                if episode.sequence is None:
                    sequence=2
                else:
                    print(episode.sequence)
                    sequence=episode.sequence+1
                inits={
                    'show':show.id,
                    'location':episode.location.id,
                    'sequence':sequence,
                    'start':episode.end + datetime.timedelta(minutes=5),
                    'duration':episode.duration,
                    'state':1,
                    }
                # roll the new episode into the query set
            else:
                # print form
                inits=None # (prevents form from being created below)
        else:
            if episodes:
                # use last Episode as a base for defaults
                episode = episodes[len(episodes)-1]
                print(episode)
                location = episode.location.id
                if episode.sequence is None:
                    sequence = 2
                else:
                    sequence = episode.sequence+1
                start = episode.end
            else:
                # first Episode of the show
                print("locations", locations)
                if locations:
                    location = locations[0].id
                sequence = 1
                # today at 6pm
                start = datetime.datetime.combine(
                            datetime.date.today(),datetime.time(18))
            inits = {
                'show':show.id,
                # 'location':location,
                'sequence':sequence, 
                'start': start,
                'duration':'00:45:00',
                'state':1,
            }
        if inits: 
            form=Episode_Form_Preshow(initial=inits, locations=locations)
    else:
        # set this so 'episode_form':form doesn't blow up
        # there are other ways of doing this, they suck too.
        form = None

    query_params = request.GET.copy()
    query_params['client'] = client.slug
    query_params['show'] = show.slug
    # query_params[''] = 

    if state is not None:
        query_params['state'] = state

    
    return render_to_response('show.html',
        {'client':client,'show':show,
          'locations':locations,
          'location_slug':location_slug,
          'episodes':episodes,
          'episode_form':form,
          'admin_params':admin_params,
          'query_params':query_params.urlencode(),
          'now':datetime.datetime.now(),
        },
        context_instance=RequestContext(request) )

 
def train(request,episode_id, episode_slug, edit_key):

    episode=get_object_or_404( Episode, id=episode_id )

    return render_to_response("approve/train.html",
                    { 'episode':episode, },
                    context_instance=RequestContext(request) )


def approve_episode(request,episode_id, episode_slug, edit_key):
    """
    Allow someone to approve a video
    Lets hope that the edit_key does not get abused.
    """
    episode=get_object_or_404( Episode, id=episode_id )

    if request.method == 'POST':
            episode.locked = datetime.datetime.now()

    who=None ## for the cases that don't use the who form

    if episode.edit_key == edit_key:
        if episode.state == 8: # review_2 -  TODO use state.slug?
            if request.method == 'POST':
                who = Who(request.POST)
                if who.is_valid(): 
                    episode.locked_by = who.cleaned_data['locked_by']
                    state = State.objects.get(sequence=episode.state)
                    log=Log(episode=episode,
                        state=state,
                        ready = datetime.datetime.now(),
                        start = datetime.datetime.now(),
                        end = datetime.datetime.now(),
                        result = episode.locked_by )
                    log.save()
                    episode.state += 1
                    episode.save()
                    template = 'approved'

            else:
                who = Who()
                template = "approve"

        elif episode.state == 1: # edit -  TODO use state.slug?
                # give the reviewer the Approve button
                template = "edit"
        else:

            # not in review 2 state
            # likely someone else already approved it
            template = "not_ready"

    else:
        # bad key
        # who knows what is going on here.
        template = "bad_key"


    return render_to_response("approve/%s.html"%template,
                    { 'episode':episode,
                        'who':who,
                    },
                    context_instance=RequestContext(request) )

def overlapping_files(request,show_id):

    show=get_object_or_404(Show,id=show_id)
    client=show.client
    raw_files=Raw_File.objects.raw(
            '''select distinct r1.* from main_raw_file r1, main_raw_file r2 
            where r1.id != r2.id 
            and not r1.trash 
            and r1.start<r2.end and r1.end>r2.start 
            and r1.location_id=r2.location_id 
            and r1.filesize=r2.filesize 
            and r1.show_id=%s and r2.show_id=%s 
            order by r1.location_id, r1.start, r1.filename, r1.filesize''', [show.id,show.id])

    rlist=[r.__dict__ for r in raw_files]

    start,end=24*60,0
    for r in rlist:

        r['location']=Location.objects.get(id=r['location_id'])
        r['show']=Show.objects.get(id=r['show_id'])
        r['client']=r['show'].client

        r['locdate'] = "%s - %s " % (
                r['location'],  r['start'].strftime("%Y%b%d") )
        r['start_min']=r['start'].hour*60+r['start'].minute
        r['end_min']=r['end'].hour*60+r['end'].minute
        if r['start_min'] < start: start = r['start_min']
        if r['end_min'] > end: end = r['start_min']
        if r['filename'][-5:] in ['-1.dv','-2.dv']:
            r['trash'] = True
            rf = Raw_File.objects.get(id=r['id'])
            rf.trash = True
            # rf.save()

    width_min = end-start

    width_px=300.0
    x=width_min/width_px +1 ## float math so that x isn't an int
    for r in rlist:
        r['start_px']=int((r['start_min']-start)/x)
        r['end_px']=int((r['end_min']-start)/x)
        r['width_px']=(r['end_px']-r['start_px'])

    return render_to_response('overlapping_raw_files.html',
        {
          'rfs':rlist,
        },
            context_instance=RequestContext(request) )


def overlapping_episodes(request,show_id):

    show=get_object_or_404(Show,id=show_id)
    client=show.client
    episodes=Episode.objects.raw('select distinct e1.* from main_episode e1, main_episode e2 where e1.id != e2.id and e1.start<e2.end and e1.end>e2.start and e1.location_id=e2.location_id and e1.show_id=%s and e2.show_id=%s order by e1.location_id, e1.start', [show.id,show.id])
    elist=[e.__dict__ for e in episodes]
    start,end=24*60,0
    for e in elist:
        e['location']=Location.objects.get(id=e['location_id'])
    start,end=24*60,0
    for e in elist:
        e['start_min']=e['start'].hour*60+e['start'].minute
        e['end_min']=e['end'].hour*60+e['end'].minute
        if e['start_min'] < start: start = e['start_min']
        if e['end_min'] > end: end = e['start_min']
    width_min = end-start

    width_px=300.0
    x=width_min/width_px +1 ## float math so that x isn't an int
    for e in elist:
        e['start_px']=int((e['start_min']-start)/x)
        e['end_px']=int((e['end_min']-start)/x)
        e['width_px']=(e['end_px']-e['start_px'])

    return render_to_response('overlapping_episodes.html',
        {
          'episodes':elist,
        },
            context_instance=RequestContext(request) )

def mini_conf(request):

    show_id = request.GET.get('show_id')
    show=get_object_or_404(Show,id=show_id)
    client=show.client

    kwargs = {
            "show": show,
            "location__active": True,
            # "emails": request.GET['emails'],
            # "show__client__slug": request.GET['client'],
            # "show__slug": request.GET['show'],
            # "state": request.GET['state'],
            # "": request.GET[''],
            }

    day = request.GET.get('day')
    if day is not None:
        kwargs['start__day']=day

    episodes=Episode.objects.filter(**kwargs).order_by(
            'location',
            'start', 
            )

    magic = request.GET.get('magic')
    print((day,magic))
    good12 = [379,380] # Case 2 & 3
    good13 = [376,378,379,380]
    if magic == '1':
        episodes = episodes.exclude(
                start__day=12,location__in=good12) 
        episodes = episodes.exclude(
                start__day=13,location__in=good13)
    elif magic == '2':
        if day == "12":
            print("here 2,12 ")
            episodes = episodes.filter(location__in=good12) 
        else:
            episodes = episodes.filter(location__in=good13) 

    return render_to_response('mini_conf.html',
        {
          'episodes':episodes,
        },
            context_instance=RequestContext(request) )


def scheduled_episodes(rf):
    # find episodes that overlap the file

    eps = Episode.objects.filter(
        Q(start__lte=rf.end)|Q(start__isnull=True),
        Q(end__gte=rf.start)|Q(end__isnull=True),
        location=rf.location)

    return eps


def orphan_dv(request,show_id):
    """
    dv files that are not associated with an episode.
    """
    
    # http://localhost:8080/main/orphan_dv/173/?format=m3u&trash=y

    format = request.GET.get('format')
    trash = request.GET.get('trash')

    size = request.GET.get('size')

    show=get_object_or_404(Show,id=show_id)
    client = show.client

    rfs=Raw_File.objects.filter(show=show).order_by('start')
    if trash is not None:
        if trash.lower() == 'n':
            rfs=rfs.filter(trash=False)
        if trash.lower() == 'y':
            rfs=rfs.filter(trash=True)

    if size is not None:
        rfs=rfs.filter(filesize__ge=size)

    orphans=[]
    for rf in rfs:
        if rf.cut_list_set.count()==0:
            eps = scheduled_episodes(rf)
            orphans.append([rf,eps])
    
    if format is None:
        return render_to_response('orphan_dv.html',
            { 'rfs':orphans, },
            context_instance=RequestContext(request) )
    elif format == 'json':
        pass
    elif format == 'm3u':

        response = HttpResponse(content_type='audio/mpegurl')
        response['Content-Disposition'] = 'inline; filename=playlist.m3u'
        writer = csv.writer(response)
        head="~/Videos/veyepar"
        for orphan in orphans:
            rf = orphan[0]
            pathname = os.path.join(head,client.slug,show.slug, 'dv',
                rf.location.slug, rf.filename )
            writer.writerow([pathname])

        return response

def episode_chaps(request, episode_id):

    episode=get_object_or_404(Episode,id=episode_id)
    cuts = Cut_List.objects.filter(
            episode=episode).order_by('sequence','raw_file__start','start')

    # start times of chapters (included cuts)
    start_chap = "00:00"
    chaps,total_time = [],0 
    for cut in cuts:
        if cut.apply:

            h,m,s = (total_time//3600, 
                    (total_time%3600)//60, 
                    total_time%60) 
            start_chap = "%s:%02i:%02i" % (h,m,s)

            yt ="{yt}?t={h}h{m}m{s}s".format(
                    yt=episode.host_url,h=h,m=m,s=s)

            cut_duration = cut.duration() // 60
            if cut_duration:
                mins = "{} min".format(cut_duration)
            else:
                mins = ""

            chaps.append((start_chap,cut,yt,mins))
            
            # setup for next chapter
            # start_chap=end_chap
            total_time+=int(cut.duration()) # durration is in seconds

        else:
            chaps.append(('',''))
 
    return render_to_response('episode_chaps.html',
        {'episode':episode,
         'chaps':chaps,
        },
        context_instance=RequestContext(request) )



def mk_cuts(episode, 
        short_clip_time = 0,
        start_slop=0, end_slop=0):

    """
    short_clip_time - threshold for the person kinda maybe starts talking and doesn't.  cut, cut, cut = small clips that need to be discarded.
    so include them in the time window, but default to not included.

    start/end slop - minutes time added to the start/end of the schedule to accommodate talks not starting or ending on time. 

    """

    # Get the overlapping dv,
    # plus some fuzz: start/end_slop
    rfs = Raw_File.objects.filter(
            end__gte=episode.start - datetime.timedelta(minutes=start_slop),
            start__lte=episode.end + datetime.timedelta(minutes=end_slop),
            location=episode.location).order_by('start')

    seq=0
    started=False ## magic to figure out when talk really started
    for rf in rfs:
        print("rf s:{}  e{}".format(rf.start, rf.end))
        seq+=1
        if (seq>1 and rf.get_minutes() > short_clip_time) or \
              episode.start == rf.start: 
            # never pre-select the first clip.  
            # unless it starts at the exact time 
            # handles start time entered after the fact.
            # and if it is the only clip...
            started = True
        cl,created = Cut_List.objects.get_or_create(
            episode=episode,
            raw_file=rf)
        if created:
            cl.sequence=seq
            # If there is only one segment, use it.
            # else:
            # if the talk has started, 
            # and there isn't something wrong with the raw
            # (like it is a dupe, or lunch)
            # and the segment is in the time slot
            if rfs.count() == 1:
                apply = True
            else:
                apply = started \
                    and not rf.trash \
                    and (rf.start < episode.end)
            cl.apply = apply

            # if there are mark clicks, 
            #   break the current file into more cuts
            marks = Mark.objects.filter(
                    location=episode.location,
                    click__gte = rf.start, click__lte = rf.end
                        ).order_by('click')
            for mark in marks:
                print("mark:{}".format(mark))
                seq+=1
                # dif is offset from start, in and out points
                dif = mark.click - rf.start
                end = dif.total_seconds()
                print('end: {}'.format(end))
                cl.end = end
                cl.save()

                start = end
                cl,created = Cut_List.objects.get_or_create(
                    episode=episode,
                    raw_file=rf,
                    start = start,
                    )
                print("cl,created: {},{}".format(cl,created))
                if created:
                    cl.sequence=seq
                    cl.apply = apply
                apply=True

            cl.save()

    return Cut_List.objects.filter(episode=episode).order_by('sequence','raw_file__start')
            

def episode(request, episode_id, episode_slug=None, edit_key=None):

    episode=get_object_or_404(Episode,id=episode_id)
    show=episode.show
    location=episode.location
    client=show.client

    email_eps = None
    if request.user.is_authenticated():
        if not episode.emails and episode.authors:

            # mine emails
            email_eps = []
            for author in episode.authors.split(','):
                email_eps.extend( Episode.objects.filter(
                    authors__icontains = author.strip(),
                    ).exclude( emails='', ))
    else:
        # hide emails if user is not logged n
        episode.emails = None
 
    try:
        # why Start/End can't be null:
        # http://code.djangoproject.com/ticket/13611
        # prev_episode = episode.get_previous_by_start(show=show)
        prev_episode = episode.get_previous_by_start(
                show=show, location=location)
    except Episode.DoesNotExist:
        # at edge of the set of nulls or values.  
        prev_episode = None
           
    try:
        next_episode = episode.get_next_by_start(
                show=show, location=location)
    except Episode.DoesNotExist:
        next_episode = None

    cuts = Cut_List.objects.filter(
            episode=episode).order_by('sequence','raw_file__start','start')

    # If this episode is still being edited, create or add cuts
    # if episode.state==1:
    # This didn't work, put back the "only if empty"
    if not cuts:
        cuts = mk_cuts(episode)

    if cuts:
        offset = abs( cuts[0].raw_file.start - episode.start )
    else:
        offset = None

   
    clrfFormSet = formset_factory(clrfForm, extra=0)
    if request.method == 'POST' and \
            (request.user.is_authenticated() or 
                    episode.edit_key == edit_key): 

        episode_form = Episode_Form_small(request.POST, instance=episode) 
        clrfformset = clrfFormSet(request.POST) 
        add_cutlist_to_ep = Add_CutList_to_Ep(request.POST)

        if episode_form.is_valid() \
              and clrfformset.is_valid() \
              and add_cutlist_to_ep.is_valid(): 
            episode_form.save()
            for form in clrfformset.forms:
                cl=get_object_or_404(Cut_List,id=form.cleaned_data['clid'])

                cl.raw_file.trash=form.cleaned_data['trash']
                cl.raw_file.comment=form.cleaned_data['rf_comment']
                cl.raw_file.save()

                cl.sequence=form.cleaned_data['sequence']
                cl.start=form.cleaned_data['start']
                cl.end=form.cleaned_data['end']
                cl.apply=form.cleaned_data['apply']
                cl.comment=form.cleaned_data['cl_comment']
                cl.save()

                if form.cleaned_data['split']:
                    # copy the current cut list.
                    # this gives 2 pointers to the same Raw File
                    cl.id=None
                    cl.sequence+=1
                    cl.save(force_insert=True)

            if add_cutlist_to_ep.cleaned_data['getit']:
                rf_filename = add_cutlist_to_ep.cleaned_data['rf_filename']
                sequence = add_cutlist_to_ep.cleaned_data['sequence']
                rfs = Raw_File.objects.filter(filename=rf_filename)
                for rf in rfs:
                    cl = Cut_List.objects.create(
                        episode=episode,
                           raw_file=rf,
                           apply = True,
                           sequence = sequence, )
                    cl.save()
                    sequence +=10


            # get current data and load into forms

            cuts = Cut_List.objects.filter(
                episode=episode).order_by(
                        'sequence', 'raw_file__trash','raw_file__start')

            init = [{'clid':cut.id,
                'trash':cut.raw_file.trash,
                'sequence':cut.sequence,
                'start':cut.start, 'end':cut.end,
                'apply':cut.apply,
                'cl_comment':cut.comment, 'rf_comment':cut.raw_file.comment,
                 } for cut in cuts]
            clrfformset = clrfFormSet(initial=init)

        else:
            # pass
            print("ep errors:", episode_form.errors)
            print("clrf errors:", clrfformset.errors)
            print("add cut.. errors:", add_cutlist_to_ep.errors)
            for e in add_cutlist_to_ep.errors:
                print(e)
    else:
        episode_form = Episode_Form_small(instance=episode) 
        # init data with things in the queryset that need editing
        # this part seems to work.
        init = [{'clid':cut.id,
                'trash':cut.raw_file.trash,
                'sequence':cut.sequence,
                'start':cut.start, 'end':cut.end,
                'apply':cut.apply,
                'cl_comment':cut.comment, 'rf_comment':cut.raw_file.comment,
        } for cut in cuts]
        clrfformset = clrfFormSet(initial=init)

    # start times of chapters (included cuts)
    start_chap = (0,"00:00") # frame, timestamp
    chaps,frame_total = [],0 
    for cut in cuts:

        if cut.apply:
            frame_total+=int(cut.duration())
            end_chap = (int(frame_total*29.27), "%s:%02i:%02i" %  
              (frame_total//3600, (frame_total%3600)//60, frame_total%60) )
            chap = [start_chap,end_chap]
            # setup for next chapter
            start_chap=end_chap
        else:
            chap = ['','']

        chap.append(cut)

        wall_start = cut.raw_file.start \
                + datetime.timedelta(seconds = cut.get_start_seconds())
        wall_end = cut.raw_file.start \
                + datetime.timedelta(seconds = cut.get_end_seconds())
        chap.append((wall_start,wall_end,))

        chaps.append(chap)
 
    # default to next Raw_File 
    rf_filename = ''
    seq = 10 ## 10 gives it room for shuffling
    if cuts:
        ## use cut left over from somewhere above.  should work.
        seq = cut.sequence + 10 
        next_rf = next(cut.raw_file)
        if next_rf is not None:
            rf_filename = next_rf.filename

    add_cutlist_to_ep=Add_CutList_to_Ep(
            initial = {'sequence':seq,
                    'rf_filename':rf_filename, })

# If all the dates are the same, don't bother displaying them
    if episode.start is None or episode.end is None:
      same_dates = False
    else:
      talkdate = episode.start.date()
      same_dates = talkdate==episode.end.date()
      for cut in cuts:
        same_dates = same_dates and \
            talkdate==cut.raw_file.start.date()==cut.raw_file.end.date()

    return render_to_response('episode.html',
        {'episode':episode,
        'email_eps': email_eps,
        'offset':offset,
        'chaps':chaps,
        'client':client, 'show':show, 'location':location,
        'prev_episode':prev_episode,
        'next_episode':next_episode,
        'same_dates':same_dates,
        'episode_form':episode_form,
        'clrffs':list(zip(cuts,chaps,clrfformset.forms)),
        'clrfformset':clrfformset,
        'add_cutlist_to_ep':add_cutlist_to_ep,
        },
        context_instance=RequestContext(request) )
        
def episode_logs(request, episode_id):
    print(episode_id)
    episode = get_object_or_404(Episode, id=episode_id)
    logs = episode.log_set.order_by('start')
    return render_to_response('episode_logs.html',
        {'episode':episode,
         'logs':logs,
        },
        context_instance=RequestContext(request) )


def claim_episode_lock(request, episode_id):
    assert request.user.is_authenticated()

    episode = get_object_or_404(Episode, id=episode_id)

    episode.locked = datetime.now()
    episode.locked_by = request.user.username
    episode.save()

    return HttpResponseRedirect(
        reverse(
            'episode_list',
            kwargs={
                'client_slug': episode.show.client.slug,
                'show_slug': episode.show.slug}))

